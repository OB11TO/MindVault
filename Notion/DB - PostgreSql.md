---
modified: 2024-09-24T14:26:44+03:00
---
## База

### Определение

`Реляционная база данных (RDBMS) -` это тип базы данных, в которой данные организованы и доступны в ==виде наборов таблиц==. В реляционной базе данных каждая таблица представляет собой набор записей, состоящих из строк и столбцов, где каждый столбец представляет атрибут данных, а каждая строка представляет собой отдельную запись.

![[images/Untitled 148.png|Untitled 148.png]]

![[images/Untitled 1 9.png|Untitled 1 9.png]]

![[images/Untitled 2 8.png|Untitled 2 8.png]]

![[images/Untitled 3 8.png|Untitled 3 8.png]]

### DDL DATA DEFINITION LANGUAGE

- CREATE создает таблицу или другой объект в БД
- ALTER модиифицирует существующий в БД объект, такой как таблица
- DROP удаляет объект в БД

```SQL
-- CREATE 
CREATE DATABASE repository;
CREATE SCHEMA ...
CREATe TABLE employees;


--ALTER 

ALTER TABLE employees someAction();
ALTER TABLE employees ADD column email VARCHAR(20);

--DROP удаляет существующую таблицу, представление таблицы или другой объект в БД
DROP TABLE employees;
```

### DML DATA MANIPULATION LANGUAGE

- SELECT извлекает записи
- INSERT создает записи
- UPDATE модифицирует записи
- DELETE удаляет записи
- TRUNCATE очищает записи из таблицы

  

```SQL
--SELECT
SELECT * from employees where salary > 1000;

--INSERT

INSERT INTO employees (id,name, lasst_name,salary)
VALUES (1, 'Vadim', 'Konovalov', 1000);

--UPDATE
UPDATE PERSON SET name = 'Dmitriy' where last_name = 'Konovalov'

--DELETE

DELETE from employees where last_name LIKE '%lov';
```

  

### CONSTRAINTS

- UNIQUE уникальный
- NOT NULL
- CHECK проверка условия
- PRIMARY KEY = UNIQUE + NOT NULL первичный ключ
- FOREIGN KEY связывание с внешней бд
- SERIAL автоинкремент  


  

```SQL
CREATE TABLE employees (
id SERIAL PRIMARY KEY,

name VARCHAR(128) NOT NULL,

dateOFWork DATE VARCHAR(32) CHECK(dateOfWork BETWEEN '01-01-2000' AND '12-12-2023'),
pc_no INT UNIQUE,
company_id INT REFERENCES companys(id)  -- FOREIGN KEY
);
```

  

### Нормальные формы

![[images/Untitled 4 8.png|Untitled 4 8.png]]

![[images/Untitled 5 8.png|Untitled 5 8.png]]

![[images/Untitled 6 7.png|Untitled 6 7.png]]

![[images/Untitled 7 7.png|Untitled 7 7.png]]

### Нормальная форма 1

![[images/Untitled 8 7.png|Untitled 8 7.png]]

==**Плохо**==

![[images/Untitled 9 7.png|Untitled 9 7.png]]

**==Хорошо==**

![[images/Untitled 10 5.png|Untitled 10 5.png]]

### Нормальная форма 2

![[images/Untitled 11 5.png|Untitled 11 5.png]]

**==Хорошо==**

![[images/Untitled 12 5.png|Untitled 12 5.png]]

### Нормальная форма 3

![[images/Untitled 13 5.png|Untitled 13 5.png]]

**==Хорошо==**

![[images/Untitled 14 4.png|Untitled 14 4.png]]

### ==1НФ==

- В таблице ==не должно быть дублирующих строк==
- В каждой таблице ==хранятся атомарные значения== (одно не составное значение)
- В ==столбце== ==хранятся данные одного типа==
- ==Отсутствуют массивы и списки в любом виде==

### ==2НФ==

- Таблица должна находиться в первой нормальной форме
- Таблица должна иметь ==первичный ключ== `PRIMARY-KEY`
- ==Все неключевые столбцы таблицы должны зависеть от== ==полного== ==ключа== (в случае если он составной).

### ==3НФ==

Требование третьей нормальной формы (3NF) заключается в том, чтобы в таблицах отсутствовала транзитивная зависимость.

`==Транзитивная зависимость==` - это ==когда неключевые столбцы зависят от значений других неключевых столбцов.==

Если в первой нормальной форме наше внимание было нацелено на соблюдение  
реляционных принципов, во второй нормальной форме в центре нашего  
внимания был первичный ключ, то в третьей нормальной форме все наше  
внимание уделено столбцам, которые не являются первичным ключом, т.е.  
неключевым столбцам.  

Чтобы нормализовать базу данных до третьей  
нормальной формы, необходимо сделать так, чтобы в таблицах отсутствовали  
неключевые столбцы, которые зависят от других неключевых столбцов.  

Иными словами, неключевые столбцы не должны пытаться играть роль ключа в  
таблице, т.е. они действительно должны быть неключевыми столбцами, такие  
столбцы не дают возможности получить данные из других столбцов, они  
дают возможность посмотреть на информацию, которая в них содержится, так  
как в этом их назначение.  

==Главные правила третьей нормальной форме (3NF) звучат следующим образом:==

- Таблица должна находиться во второй нормальной форме
- В таблице должна отсутствовать транзитивная зависимость неключевых столбцов

Пример транзитивной зависимости тип контакта не зависит от работника, зависит только от колонки contact, это нарушает 3 форму, решение вынести contact и contact_type в отдельную таблицу и ссылаться на нее по id через references.

| id  | name  | last_name | contact | contact_type |
| --- | ----- | --------- | ------- | ------------ |
| 1   | Вадим | Коновалов | 8911901 | домашний     |


### FOREIGN KEYS виды (Связи между таблицами)

`One to many` Покупатель -Заказы, РК -уникальный, FK - может иметь дубликаты

```SQL
CREATE TABLE CHILD(
child_id INT,
parent_id NOT NULL REFERENCES parents(parent_id)
);
```

![[images/Untitled 15 4.png|Untitled 15 4.png]]

`One to one` Гражданин - Паспорт , не может быть id, которого нет в паспортах

```SQL
CREATE TABLE passport(
passport_id INT PRIMARY KEY REFERENCES citizens(citizen_id)
);
```

![[images/Untitled 16 4.png|Untitled 16 4.png]]

![[images/Untitled 17 4.png|Untitled 17 4.png]]

`Many to Many` Актеры - Фильмы, создается join таблица

```SQL
CREATE TABLE actors_movies(
actor_id INT REFERENCES actors(actor_id),

movie_id INT REFERENCES citizens(movie_id)
);
```

![[images/Untitled 18 3.png|Untitled 18 3.png]]

  
### Конкатенация данных таблиц, простое объединение таблиц

- UNION (оставляет уникальные значения)
- UNION ALL ( берет все значения)
- INTERSECT данные, которые находятся в первой и второй таблице
- EXCEPT( вычитает из первой данные второй

  

```SQL
select name from employees;
UNION
select name from old_employees;
```

### Группировка данных

==GROUP BY и HAVING==

- `==HAVING==` ==-== ==доп условия на агрегирующие функции после== `GROUP BY`

```SQL
SELECT department, AVG(salary) as avg_salary
FROM employees
GROUP BY department
HAVING AVG(salary) > 50000;
```

![[images/Untitled 19 3.png|Untitled 19 3.png]]

### Агрегатные функции

1. `AVG()` - вычисляет среднее значение
2. `COUNT()` - подсчитывает количество строк

```SQL
SELECT customer_id, COUNT(*) as order_count
FROM orders
GROUP BY customer_id
HAVING customer_id > 10
ORDER BY DESC;
```

1. `MAX()` - находит максимальное значение
2. `MIN()` - находит минимальное значение
3. `SUM()` - находит сумму значений

Эти функции могут использоваться вместе с оператором `GROUP BY` для агрегации данных в различных группах.

### Оконные функции

Мы хотим определить, сколько каждый клиент потратил на свои заказы, и добавить эту информацию в столбец "total_spent". Мы можем использовать функцию `SUM()` с `OVER` и `PARTITION BY`, чтобы выполнить эту задачу:

```SQL
CREATE TABLE orders (
    order_id int,
    customer_id int,
    order_date date,
    order_total decimal(10,2)
);

SELECT order_id, customer_id, order_date, order_total, 
       SUM(order_total) OVER (PARTITION BY customer_id) AS total_spent
FROM orders;
```

1. `ROW_NUMBER()`: присваивает уникальный номер каждой строке внутри окна, начиная с 1.
2. `RANK()`: присваивает позицию каждой строке внутри окна, с учетом повторяющихся значений.
3. `DENSE_RANK()`: присваивает позицию каждой строке внутри окна, без учета повторяющихся значений.
4. `NTILE(n)`: разбивает строки на n групп примерно одинакового размера и присваивает каждой строке номер группы.
5. `LAG(column, offset)`: возвращает значение столбца для предыдущей строки внутри окна, с отступом от текущей строки.
6. `LEAD(column, offset)`: возвращает значение столбца для следующей строки внутри окна, с отступом от текущей строки.
7. `SUM(column) OVER (PARTITION BY partition_column ORDER BY order_column)`: вычисляет сумму значения столбца для каждой строки внутри окна, сгруппированного по значениям в столбце `partition_column` и упорядоченного по значениям в столбце `order_column`.
8. `AVG(column) OVER (PARTITION BY partition_column ORDER BY order_column)`: вычисляет среднее значение столбца для каждой строки внутри окна, сгруппированного по значениям в столбце `partition_column` и упорядоченного по значениям в столбце `order_column`.
9. `MAX(column) OVER (PARTITION BY partition_column ORDER BY order_column)`: находит максимальное значение столбца для каждой строки внутри окна, сгруппированного по значениям в столбце `partition_column` и упорядоченного по значениям в столбце `order_column`.
10. `MIN(column) OVER (PARTITION BY partition_column ORDER BY order_column)`: находит минимальное значение столбца для каждой строки внутри окна, сгруппированного по значениям в столбце `partition_column` и упорядоченного по значениям в столбце `order_column`.

![[images/Untitled 20 3.png|Untitled 20 3.png]]

### Сортировка

```SQL
SELECT * from employees ORDER BY salary ASC; -- можно опустить по возрастанию

SELECT * from employees ORDER BY salary DESC; -- по убыванию
```

  
### View

`Представление (VIEW)` — объект базы данных, являющийся результатом выполнения запроса к базе данных, определенного с помощью оператора SELECT, в момент
обращения к представлению. Представления иногда называют "виртуальными таблцами".
Такое название связано с тем, что представление доступно для пользователя как таблица, но само оно не содержит данных, а извлекает их из таблиц в момент обращения к нему.
`Представления (view`s) – это объекты базы данных, которые всегда создаются на основе одной или более базовых таблиц (или других представлений), используя информацию метаданных. Эта информация (включая имя представления
и способ получения строк из базовых таблиц) – все, что сохраняется физически для представления. Именно по этой причине представления также называют виртуальными таблицами. Если говорить упрощенно, то это SQL-запрос, который можно выполнять, обращаясь к нему по заранее указанному имени.
`Материализованное представление` это объект базы данных, значением которого является сохраненный результат заранее выполненного запроса, заданного при создании материализованного представления. Повторное вычисление и сохранение полученного результата происходит согласно правилам, которые определяются при создании материализованного представления.
В упрощенном виде – это SQL-запрос, который можно выполнять, обращаясь к нему по заранее указанному имени, и результат выполнения этого запроса сохраняется для дальнейшего использования.
- Используют индексы

![[images/Untitled 21 3.png|Untitled 21 3.png]]

### Курсор

`**Курсор**` — это объект базы данных, который позволяет приложениям работать с записями «по одной», а не сразу с множеством, как это делается в обычных SQL командах.

Порядок работы с курсором такой:

- Определить курсор (`DECLARE`)
- Открыть курсор (`OPEN`)
- Получить запись из курсора (`FETCH`)
- Обработать запись…
- Закрыть курсор (`CLOSE`)
- Удалить ссылку курсора (`DEALLOCATE`). Когда удаляется последняя ссылка курсора, SQL освобождает структуры данных, составляющие курсор.

## JOINS

### INNER JOIN

или просто JOIN . объединяет, не беря в расчет данные, у которых нет связи


```SQL
SELECT * from employees JOIN companys ON employees.id = companys.id;
```

### CROSS JOIN

Декартово произведение, например перемножить места в таблице seat для самолета

  

```SQL
INSERT INTO seat(aircraft_id, seat_no)
SELECT id, s.column1 from aircraft
CROSS JOIN (VALUES ('A1'),('A2'),('B1'),('B2'),('C1'),('C2'),('D1'),('D2') order by 1);
```

### LEFT JOIN
  

Таблица `customers`:

|             |               |
| ----------- | ------------- |
| customer_id | customer_name |
| 1           | John          |
| 2           | Emily         |
| 3           | Michael       |
| 4           | Sarah         |
| 5           | David         |

Таблица `orders`:

|   |   |   |
|---|---|---|
|order_id|order_date|customer_id|
|1|2022-04-15|1|
|2|2022-04-16|2|
|3|2022-04-17|1|
|4|2022-04-18|3|
|5|2022-04-19|1|

1. `LEFT JOIN`

В запросе ниже мы используем `LEFT JOIN`, чтобы выбрать все записи из таблицы `customers`, а также связанные с ней записи из таблицы `orders`, если они существуют

  

```SQL
SELECT customers.customer_name, orders.order_date
FROM customers
LEFT JOIN orders ON customers.customer_id = orders.customer_id;

```

Результатом этого запроса будет таблица, в которой будут перечислены все имена клиентов из таблицы `customers`, а также даты заказов, если они есть. Если для клиента нет заказов, то значение в столбце `order_date` будет `NULL`. Таким образом, результат будет таким:

|   |   |
|---|---|
|customer_name|order_date|
|John|2022-04-15|
|John|2022-04-17|
|Emily|2022-04-16|
|Michael|2022-04-18|
|Sarah|NULL|
|David|NULL|

  

### RIGHT JOIN

В запросе ниже мы используем `RIGHT JOIN`, чтобы выбрать все записи из таблицы `orders`, а также связанные с ней записи из таблицы `customers`, если они существуют:

```SQL
SELECT customers.customer_name, orders.order_date
FROM customers
RIGHT JOIN orders ON customers.customer_id = orders.customer_id;
```

Результатом этого запроса будет таблица, в которой будут перечислены все даты заказов из таблицы `orders`, а также имена клиентов, если они есть. Если для заказа нет соответствующего клиента, то значение в столбце `customer_name` будет `NULL`. Таким образом, результат будет таким:

|   |   |
|---|---|
|customer_name|order_date|
|John|2022-04-15|
|Emily|2022-04-16|
|John|2022-04-17|
|Michael|2022-04-18|
|NULL|2022-04-19|

### FULL JOIN

```SQL
SELECT customers.customer_name, orders.order_date
FROM customers
FULL JOIN orders ON customers.customer_id = orders.customer_id;
```

Результатом этого запроса будет таблица, содержащая все имена клиентов и даты заказов, при этом значения будут `NULL`, если для них нет соответствующей записи в другой таблице. Таким образом, результат будет таким:

|   |   |
|---|---|
|customer_name|order_date|
|John|2022-04-15|
|John|2022-04-17|
|Emily|2022-04-16|
|Michael|2022-04-18|
|Sarah|NULL|
|David|NULL|
|NULL|2022-04-19|

## Индексы, B-Tree

![[images/Untitled 22 3.png|Untitled 22 3.png]]

![[images/Untitled 23 3.png|Untitled 23 3.png]]

### Создание индексов

Плюсы:

Ускоряет поиск по БД

  

Минусы:

Занимают память

Замедляют операции изменение данных

Реиндексация при кластерных индексах

  

Создание индекса для одного столбца.

В этом примере мы создаем индекс с именем `idx_name` для столбца `name` в таблице `products`. Этот индекс ускорит выполнение запросов на выборку данных по значению столбца `name`.

```SQL
CREATE INDEX idx_name ON products (name);
```

Создание индекса для нескольких столбцов.

В этом примере мы создаем индекс с именем `idx_name_code` для столбцов `name` и `code` в таблице `products`. Этот индекс ускорит выполнение запросов на выборку данных по значениям столбцов `name` и `code` вместе.

```SQL
CREATE UNIQUE INDEX idx_code ON products (code);
```

Создание уникального индекса

В этом примере мы создаем уникальный индекс с именем `idx_code` для столбца `code` в таблице `products`. Этот индекс гарантирует, что значения в столбце `code` будут уникальными и ускорит выполнение запросов на выборку данных по значению столбца `code`.

```SQL
CREATE UNIQUE INDEX idx_code ON products (code);
```

- ==**Cоставной**== ==индекс== `ограничен` ==`16`== ==столбцами== или `==900==` ==байтами==

  

### Виды индексов под капотом

1. ==**B-деревья (B-trees)**====:==
    - B-деревья являются одним из наиболее распространенных и эффективных алгоритмов индексации в базах данных.
    - Они обеспечивают эффективный поиск, вставку и удаление элементов в индексе.
    - B-деревья поддерживают сбалансированное дерево, которое позволяет быстро найти нужный элемент, используя логарифмическое время.
    - B-деревья широко используются для индексации в различных СУБД, таких как PostgreSQL, MySQL, Oracle и других.
2. ==**B+ деревья (B+-trees)**====:==
    
    - B+ деревья являются вариацией B-деревьев и также широко используются для индексации в базах данных.
    - В отличие от B-деревьев, B+ деревья хранят ключи только в листовых узлах, что делает их более эффективными для поиска.
    - B+ деревья обеспечивают хорошую поддержку для диапазонных запросов.
    - Этот тип индексации также широко применяется в различных СУБД.
    
    Вот пример простой схемы B+ дерева с тремя уровнями (корень, внутренние узлы, листовые узлы):
    
    ```CSS
                    [ K1, K2, K3 ]
                     /     |       \
                   /       |        \
           [ K1 ]         [ K2 ]       [ K3 ]
          /  |  \        /  |  \      /  |  \
      /    |     \    /     |     \  /    |    \
    [L1] [L2] [L3] [L4] [L5] [L6] [L7] [L8] [L9]
    
    ```
    
    - `**K1**`, `**K2**`, `**K3**`: ключи внутренних узлов.
    - `**L1**` до `**L9**`: данные (или ссылки на данные) в листовых узлах.
    
    Ключевая особенность здесь заключается в том, что данные хранятся только в листовых узлах, а внутренние узлы служат для направления поиска.
    
3. ==**Хеш-индексы (Hash indexes)**====:==
    - Хеш-индексы используют хеш-функции для быстрого поиска ключей.
    - Они обеспечивают очень быстрый поиск, но могут быть менее эффективными для диапазонных запросов.
    - Хеш-индексы часто используются для индексации в памяти или для индексации столбцов с высокой степенью уникальности значений.
4. ==**GiST (Generalized Search Tree)**====:==
    
    - GiST - это обобщенное дерево поиска, которое позволяет определять собственные типы данных и методы поиска.
    - Он предоставляет гибкую индексацию для различных типов данных, таких как географические данные, полнотекстовый поиск и другие.
    
    1. **GIST (Generalized Search Tree)**:
        - GIST является обобщенной структурой данных, которая может хранить произвольные типы данных и поддерживать произвольные типы запросов на поиск и сравнение.
        - GIST может использоваться для индексации данных, которые не могут быть эффективно обработаны стандартными структурами данных, такими как B-деревья.
        - GIST поддерживает несколько типов операций поиска и сравнения, включая операции на основе расстояния и условные операции.
        - Примеры использования GIST включают пространственные индексы (например, для географических данных) и индексы для полнотекстового поиска.
    2. **B-деревья (B-trees)**:
        - B-деревья являются структурой данных, оптимизированной для индексации и поиска данных в базах данных.
        - Они предназначены для индексации ключей и обычно используются для индексации значений в базах данных, таких как строки или числа.
        - B-деревья хранят ключи в упорядоченном виде и обеспечивают эффективную поддержку операций вставки, удаления и поиска.
        - Основное применение B-деревьев - это индексация данных в базах данных для ускорения операций выборки данных.
    
    Вот пример обобщенного дерева поиска GIST и B-дерева:
    
    ```VB.Net
    vbnetCopy code
                         GIST Tree
              /               |               \
         /             |              \
    Spatial Data      Text Search      Custom
      Index            Index           Index
    
    
                       B-tree
              /               |               \
         /             |              \
    Keys in Order    Keys in Order    Keys in Order
       with            with            with
       Pointers        Pointers        Pointers
    
    ```
    
    На этом изображении:
    
    - В GIST Tree узлы могут быть индексированы различными способами, включая пространственные данные, полнотекстовый поиск и другие пользовательские типы данных.
    - В B-tree узлы содержат ключи в упорядоченном виде, а каждый ключ сопровождается указателем на соответствующие данные.
5. ==**GIN (Generalized Inverted Index)**====:==
    - GIN - это обобщенный инвертированный индекс, который часто используется для индексации списков или массивов.
    - Он предоставляет эффективный поиск по значениям, содержащимся в таких структурах данных.

### USING

1. B-tree индекс с оператором `USING`:

```Plain
CREATE INDEX idx_name ON products USING BTREE (name);

```

В этом примере мы создаем B-tree индекс с именем `idx_name` для столбца `name` в таблице `products`. Оператор `USING` используется для явного указания типа индекса, в данном случае B-tree. Этот тип индекса эффективен для поиска точных значений, сравнения диапазонов и сортировки данных.

1. GIN индекс с оператором `USING`:

```Plain
CREATE INDEX idx_tags ON products USING GIN (tags);

```

В этом примере мы создаем GIN индекс с именем `idx_tags` для столбца `tags` в таблице `products`. Оператор `USING` используется для явного указания типа индекса, в данном случае GIN. Этот тип индекса оптимизирован для поиска в массивах или списковых структурах данных.

1. BRIN индекс с оператором `USING`:

```Plain
CREATE INDEX idx_sales ON orders USING BRIN (sale_date);

```

В этом примере мы создаем BRIN индекс с именем `idx_sales` для столбца `sale_date` в таблице `orders`. Оператор `USING` используется для явного указания типа индекса, в данном случае BRIN. Этот тип индекса эффективен для больших таблиц, которые хранят данные в определенном порядке, например, временных рядах или геоданных.

1. GiST индекс с оператором `USING`:

```Plain
CREATE INDEX idx_points ON locations USING GiST (point);

```

В этом примере мы создаем GiST индекс с именем `idx_points` для столбца `point` в таблице `locations`. Оператор `USING` используется для явного указания типа индекса, в данном случае GiST. Этот тип индекса оптимизирован для поиска в геоданных и других типах сложных структур данных.

1. SP-GiST индекс с оператором `USING`:

```Plain
CREATE INDEX idx_polygons ON areas USING SPGIST (polygon);

```

В этом примере мы создаем SP-GiST индекс с именем `idx_polygons` для столбца `polygon` в таблице `areas`. Оператор `USING` используется для явного указания типа индекса, в данном случае SP-GiST. Этот тип индекса оптимизирован для поиска в сложных геометрических структурах

### Создание частичного, на выражение, на функцию, с опцией сортировки

1. Создание частичного индекса:

```SQL
CREATE INDEX idx_active_products ON products (id) WHERE active = true;
```

В этом примере мы создаем частичный индекс с именем `idx_active_products` для столбца `id` в таблице `products`, который будет содержать только активные записи. Этот тип индекса может быть полезен для ускорения запросов, которые фильтруют данные по условиям, включающим только часть таблицы.

1. Создание индекса на вычисляемое выражение:

```SQL
CREATE INDEX idx_total_price ON orders (total_price / quantity);
```

В этом примере мы создаем индекс с именем `idx_total_price` для вычисляемого выражения `total_price / quantity` в таблице `orders`. Этот тип индекса может быть полезен для ускорения запросов на выборку данных, которые используют вычисляемые выражения в качестве фильтров или сортировок.

1. Создание индекса на функцию:

```SQL
CREATE INDEX idx_upper_name ON products (UPPER(name));
```

В этом примере мы создаем индекс с именем `idx_upper_name` для значения столбца `name`, приведенного к верхнему регистру с помощью функции `UPPER()`. Этот тип индекса может быть полезен для ускорения запросов на выборку данных, которые используют функции в качестве фильтров или сортировок.

1. Создание индекса с опцией сортировки:

```SQL
CREATE INDEX idx_name_desc ON products (name DESC);
```

В этом примере мы создаем индекс с именем `idx_name_desc` для столбца `name` в таблице `products`, отсортированного в обратном порядке. Этот тип индекса может быть полезен для ускорения запросов на выборку данных, которые используют сортировку по убыванию.

### Кластерный и обычный индекс

Предположим, у нас есть база данных, которая хранит информацию о книгах в библиотеке. Давайте рассмотрим пример с использованием кластерного и обычного (некластеризованного) индексов.

Предположим, у нас есть таблица `**Books**`, содержащая информацию о книгах. Пусть у этой таблицы есть столбцы:

- `**BookID**` (идентификатор книги),
- `**Title**` (название книги),
- `**Author**` (автор книги),
- `**Genre**` (жанр книги).

**Пример с кластерным индексом:**

Предположим, мы решаем сделать индекс по столбцу `**Author**`. Мы делаем этот индекс кластерным.

В этом случае, книги в таблице `**Books**` будут физически упорядочены по авторам. Например:

```Markdown

BookID | Title           | Author        | Genre
-----------------------------------------------
1      | Book1           | AuthorA       | Fiction
2      | Book2           | AuthorB       | Non-Fiction
3      | Book3           | AuthorB       | Fiction
4      | Book4           | AuthorC       | Mystery
5      | Book5           | AuthorD       | Biography

```

Здесь мы видим, что книги упорядочены по столбцу `**Author**`. Это значит, что все книги автора A будут идти первыми, затем книги автора B и так далее.

**Пример с обычным (некластеризованным) индексом:**

Предположим, мы решаем сделать обычный индекс по столбцу `**Genre**`.

В этом случае, индекс будет указывать, где находятся книги разных жанров в таблице, но сама таблица `**Books**` останется неупорядоченной по жанру. Например:

```Markdown

BookID | Title           | Author        | Genre
-----------------------------------------------
1      | Book1           | AuthorA       | Fiction
2      | Book2           | AuthorB       | Non-Fiction
3      | Book3           | AuthorB       | Fiction
4      | Book4           | AuthorC       | Mystery
5      | Book5           | AuthorD       | Biography

```

Здесь индекс по жанру будет указывать, например, что все книги жанра "Fiction" находятся на строках с ID 1 и 3, но порядок строк в таблице не будет зависеть от жанра книги.

Таким образом, кластерный индекс изменяет физический порядок хранения строк в таблице, в то время как обычный индекс только указывает на их местоположение.

  

По умолчанию PostgreSQL создает кластерный индекс (CLUSTER) для первичного ключа. Это означает, что если вы определяете столбец как первичный ключ (PRIMARY KEY) при создании таблицы, PostgreSQL автоматически создает кластерный индекс для этого столбца.

Например:

```SQL
sqlCopy code
CREATE TABLE Books (
    BookID SERIAL PRIMARY KEY,
    Title VARCHAR(255),
    Author VARCHAR(255),
    Genre VARCHAR(50)
);

```

В этом примере столбец `**BookID**` определен как первичный ключ с помощью ключевого слова `**PRIMARY KEY**`. PostgreSQL автоматически создаст кластерный индекс для столбца `**BookID**`, который будет определять фактический порядок хранения строк в таблице.

### Вопросы

### ==**Можно ли создать кластеризованный индекс на столбце, содержащем дубликаты?**==

`И да, и нет.` Да ==вы можете создать кластеризованный индекс на ключевом столбце, содержащем дубликаты значений. Нет, значение ключевого столбца не смогут остаться в состоянии не уникальности==. Позвольте объяснить. Если вы создаёте неуникальный кластерный индекс (non-unique clustered index) на столбце, то подсистема хранения данных добавляет к дублирующему значению целочисленное значение (uniquifier), чтобы удостовериться в уникальности и, соответственно, обеспечить возможность идентифицировать каждую строку в кластеризованной таблице.

К примеру, вы можете решить создать в таблице с данными о клиентах кластеризованный индекс по столбцу

_LastName_, хранящим фамилию. Столбец содержит такие значения как Franklin, Hancock, Washington и Smith. Затем вы вставляете значения Adams, Hancock, Smith и снова Smith. Но значение ключевого столбца обязательно должны быть уникальны, поэтому подсистема хранения данных изменит значение дубликатов таким образом, что ==они будут выглядеть примерно так: Adams, Franklin, Hancock, Hancock1234, Washington, Smith, Smith4567 и Smith5678.==

На первый взгляд такой подход кажется нормальным, но целочисленное значение увеличивает размер ключа, что может стать проблемой при большом количестве дубликатов, а эти значения станут основой некластеризованного индекса или ссылкой внешнего ключа. По этим причинам вы всегда должны стараться создавать уникальный кластеризованный (unique clustered indexes) при любой возможности. Если это невозможно, то по крайней мере постарайтесь использовать столбцы с очень высоким содержание уникальных значений.

## План выполнения Explan

### Теория

- Сейчас ==есть только стоимостной==
- Определяет `page_cost` —> ==сколько сегментов нужно считать== ==на жестком диске==
- `cpu_cost` - цена процессора, сколько у нас ==записей в таблице==
- Всё можно найти в pg_class
- `Seq Scan - вся таблица пройдена`
- `width` - ==вес строки==

![[images/Untitled 24 3.png|Untitled 24 3.png]]

![[images/Untitled 25 3.png|Untitled 25 3.png]]

![[images/Untitled 26 3.png|Untitled 26 3.png]]

### План выполнения: Индексы

![[images/Untitled 27 3.png|Untitled 27 3.png]]

  

![[images/Untitled 28 3.png|Untitled 28 3.png]]

  

![[images/Untitled 29 3.png|Untitled 29 3.png]]

![[images/Untitled 30 3.png|Untitled 30 3.png]]

- `Для разных индексов`

![[images/Untitled 31 3.png|Untitled 31 3.png]]

![[images/Untitled 32 3.png|Untitled 32 3.png]]

  

## Триггеры

`Триггеры` — это ==части кода, запускаемые автоматически и основанные==

==на каком-либо действии или событии в таблице базы данных.==

Триггеры могут применять в таблице во время выполнения операторов

`INSERT, UPDATE или DELETE`, а ==затем работать или перед, или после этих действий.==

Некоторые СУБД также позволяют работать триггерам на уровне оператора

или на уровне каждой строки данных во время ее изменения.

`Триггеры событий`

С точки зрения событий триггеры можно разделить на 3 группы.

1. ==BEFORE== (до выполнения операции);
2. ==INSTEAD OF== (вместо выполнения операции);
3. ==AFTER== (после выполнения операции).

`Уровень работы триггеров`

- триггеры ==уровня строки(row)== запускаются каждый раз заново для каждой отдельной строки (записи таблицы), которая будет затронута SQL-запросом;
- триггеры ==уровня запроса(statement)== запускаются один раз для всего SQL-запроса.

![[images/Untitled 33 3.png|Untitled 33 3.png]]

## DWH

![[images/Untitled 34 3.png|Untitled 34 3.png]]

![[images/Untitled 35 3.png|Untitled 35 3.png]]

![[images/Untitled 36 3.png|Untitled 36 3.png]]

![[images/Untitled 37 3.png|Untitled 37 3.png]]

![[images/Untitled 38 3.png|Untitled 38 3.png]]

![[images/Untitled 39 3.png|Untitled 39 3.png]]

![[images/Untitled 40 3.png|Untitled 40 3.png]]

## Теорема CAP / NoSql

![[images/Untitled 41 3.png|Untitled 41 3.png]]

![[images/Untitled 42 3.png|Untitled 42 3.png]]

![[images/Untitled 43 3.png|Untitled 43 3.png]]

![[images/Untitled 44 3.png|Untitled 44 3.png]]

![[images/Untitled 45 3.png|Untitled 45 3.png]]

![[images/Untitled 46 3.png|Untitled 46 3.png]]

![[images/Untitled 47 3.png|Untitled 47 3.png]]

![[images/Untitled 48 3.png|Untitled 48 3.png]]

![[images/Untitled 49 3.png|Untitled 49 3.png]]

  

## Транзакции

`Транзакция` - это ==_единица работы в рамках соединения с базой данных_==, либо выполняется полностью `COMMIT`, либо полностью откатывается `ROLLBACK`

### ACID

`ACID` - это акроним от атомарности (Atomicity), согласованности (Consistency), изолированности (Isolation) и долговечности (Durability). ==Эти свойства обеспечивают целостность данных и надежность транзакций в базах данных.==

- `Атомарность (Atomicity)` означает, что ==транзакции должны быть выполнены полностью или не выполнены вовсе==. Если происходит ==ошибка во время транзакции, то все изменения должны быть отменены==, чтобы сохранить целостность базы данных.
- `Согласованность (Consistency)` ==гарантирует, что база данных всегда будет находиться в правильном состоянии после завершения транзакции.== Если ==транзакция не может быть завершена, то база данных должна быть возвращена к своему предыдущему состоянию.==
- `Изолированность (Isolation)` ==гарантирует, что транзакции, выполняемые одновременно, не будут взаимно влиять друг на друга.== Это означает, что ==результаты одной транзакции не должны быть видны другим транзакциям==, пока первая транзакция не будет завершена.
- `Долговечность (Durability)` гарантирует, что ==изменения в базе данных, выполненные в рамках транзакции, будут сохранены== и **==не будут потеряны в случае сбоя==** системы.

### Проблемы при работе с транзакциями

`Проблемы изоляции транзакций возникают,` когда ==две или более транзакции пытаются получить доступ к одним и тем же данным в базе данных одновременно.== Эти ==проблемы связаны с тем, что одна транзакция может видеть изменения, которые еще не были завершены другой транзакцией, что может привести к неправильным результатам и ошибкам в базе данных.==

Существует несколько проблем изоляции транзакций, которые могут возникнуть в базе данных.

1. `Lost update -` потерянное обновление: Эта проблема возникает, когда ==две или более транзакции пытаются изменить одну и ту же запись в базе данных одновременно==. Если одна транзакция изменяет запись первой, а другая транзакция изменяет ту же запись позже, то изменения первой транзакции будут потеряны. (`УЖЕ РЕШЕНА В СОВРЕМЕННЫХ СУБД)`

![[images/Untitled 50 3.png|Untitled 50 3.png]]

1. `Dirty read` - грязное чтение: Эта проблема возникает, когда ==одна транзакция читает данные, которые были изменены другой транзакцией, но еще не были подтверждены (commit)==. Если вторая транзакция откатывается (rollback), то данные, прочитанные из базы данных, будут неверными

![[images/Untitled 51 3.png|Untitled 51 3.png]]

1. `Non-repeatable read` - неповторяемое чтение: Эта проблема возникает, когда ==одна транзакция читает данные из базы данных, а затем другая транзакция обновляет (update) эти данные и подтверждает свои изменения==. Если первая транзакция попытается прочитать эти данные еще раз, она получит другой результат.

![[images/Untitled 52 3.png|Untitled 52 3.png]]

  
  
`Частный случай last commit wins:`  
Подход "last commit wins" предполагает, что если  
==одна транзакция изменяет данные, которые были прочитаны другой транзакцией, то последние изменения должны быть сохранены в базе данных, а изменения, сделанные первой транзакцией, будут потеряны.==

![[images/Untitled 53 3.png|Untitled 53 3.png]]

1. `Phantom read -` призрачное чтение: Эта проблема возникает, когда ==одна транзакция выполняет запрос на чтение и получает набор результатов, а затем другая транзакция вставляет, обновляет или удаляет данные, которые соответствуют этому запросу, и подтверждает свои изменения. Если первая транзакция выполняет этот же запрос еще раз, она получит другой набор результатов.==

![[images/Untitled 54 3.png|Untitled 54 3.png]]

Чтобы ==избежать этих проблем, необходимо использовать правильный уровень изоляции транзакций в базе данных, который обеспечит правильное управление параллельным доступом к данным и избежание конфликтов==. Разные СУБД могут предоставлять различные уровни изоляции, такие как `READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ и SERIALIZABLE.`

- в PG - либо `READ COMMITTED` по умолчанию, либо `SERIALIZABLE`

![[images/Untitled 55 3.png|Untitled 55 3.png]]

### Propagation

1. `**REQUIRED**`:
    
    ```Java
    
    @Transactional(propagation = Propagation.REQUIRED)
    public void methodA() {
        // Логика работы с базой данных
    }
    
    ```
    
    _Пример использования_: Если вызванный метод `**methodA()**` вызывается из другого метода, который уже работает в рамках транзакции, `**methodA()**` будет использовать эту же транзакцию. Если же вызывающий метод не находится в транзакционном контексте, будет создана новая транзакция.
    
2. `**REQUIRES_NEW**`:
    
    ```Java
    
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void methodB() {
        // Логика работы с базой данных
    }
    
    ```
    
    _Пример использования_: Метод `**methodB()**` всегда будет выполняться в собственной транзакции. Даже если он вызывается из метода, который уже работает в рамках транзакции, транзакция внешнего метода будет приостановлена, и `**methodB()**` будет выполняться в новой транзакции. Это полезно, когда вам нужно изолировать операции в базе данных в новой транзакции, чтобы гарантировать их атомарность и независимость.
    
3. `**SUPPORTS**`:
    
    ```Java
    
    @Transactional(propagation = Propagation.SUPPORTS)
    public void methodC() {
        // Логика работы с базой данных
    }
    
    ```
    
    _Пример использования_: Метод `**methodC()**` будет использовать активную транзакцию, если таковая имеется. Если вызывающий метод не находится в транзакционном контексте, `**methodC()**` будет выполняться без транзакционного контекста. Это может быть полезно, если метод может быть вызван как из транзакционного, так и из непривязанного к транзакции контекста.
    
4. `**MANDATORY**`:
    
    ```Java
    
    @Transactional(propagation = Propagation.MANDATORY)
    public void methodD() {
        // Логика работы с базой данных
    }
    
    ```
    
    _Пример использования_: Метод `**methodD()**` требует наличия активной транзакции. Если он вызывается из контекста без активной транзакции, будет сгенерировано исключение. Это полезно, когда метод должен быть вызван только в рамках уже существующей транзакции.
    
5. `**NESTED**`:
    
    ```Java
    
    @Transactional(propagation = Propagation.NESTED)
    public void methodE() {
        // Логика работы с базой данных
    }
    
    ```
    
    _Пример использования_: Метод `**methodE()**` создает вложенную транзакцию, которая является подчиненной главной транзакции. Если вложенная транзакция завершается успешно, она фиксируется. Если главная транзакция завершается неудачно, вложенная транзакция откатывается. Это полезно, когда вам нужно иметь вложенные транзакции с определенной степенью изоляции и атомарности.
    
6. `**NOT_SUPPORTED**`:
    
    ```Java
    
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    public void methodF() {
        // Логика работы с базой данных
    }
    
    ```
    
    _Пример использования_: Метод `**methodF()**` будет выполняться без транзакционного контекста. Если в момент вызова метода существует активная транзакция, она будет приостановлена до завершения метода. Это может быть полезно, если нужно выполнить операции без транзакционной защиты.
    
7. `**NEVER**`:
    
    ```Java
    
    @Transactional(propagation = Propagation.NEVER)
    public void methodG() {
        // Логика работы с базой данных
    }
    ```
    
    _Пример использования_: Метод `**methodG()**` не должен быть выполнен в контексте транзакции. Если при вызове метода существует активная транзакция, будет сгенерировано исключение. Это может быть полезно, когда вы хотите гарантировать, что метод не выполняется в рамках транзакции.
    
      
    

В этом примере метод `**deleteFileAndRecord()**` не использует аннотацию `**@Transactional**`, и это безопасно, потому что удаление файла из файловой системы и удаление соответствующей записи из базы данных - это атомарные операции, они либо обе выполняются успешно, либо ни одна из них. Таким образом, использование транзакции в этом случае не требуется и может быть избыточным, приводя к ненужным накладным расходам и увеличению нагрузки на базу данных.

Однако, если удаление файла и/или записи в базе данных зависит от других операций, которые должны быть атомарными (например, удаление файла должно быть отменено, если удаление записи из базы данных не удалось), тогда использование транзакции может быть необходимо.

### Интересные моменты

![[images/Untitled 56 3.png|Untitled 56 3.png]]