---
modified: 2024-09-24T17:30:16+03:00
---




  


## JOINS

### INNER JOIN

или просто JOIN . объединяет, не беря в расчет данные, у которых нет связи


```SQL
SELECT * from employees JOIN companys ON employees.id = companys.id;
```

### CROSS JOIN

Декартово произведение, например перемножить места в таблице seat для самолета

  

```SQL
INSERT INTO seat(aircraft_id, seat_no)
SELECT id, s.column1 from aircraft
CROSS JOIN (VALUES ('A1'),('A2'),('B1'),('B2'),('C1'),('C2'),('D1'),('D2') order by 1);
```

### LEFT JOIN
  

Таблица `customers`:

|             |               |
| ----------- | ------------- |
| customer_id | customer_name |
| 1           | John          |
| 2           | Emily         |
| 3           | Michael       |
| 4           | Sarah         |
| 5           | David         |

Таблица `orders`:

|   |   |   |
|---|---|---|
|order_id|order_date|customer_id|
|1|2022-04-15|1|
|2|2022-04-16|2|
|3|2022-04-17|1|
|4|2022-04-18|3|
|5|2022-04-19|1|

1. `LEFT JOIN`

В запросе ниже мы используем `LEFT JOIN`, чтобы выбрать все записи из таблицы `customers`, а также связанные с ней записи из таблицы `orders`, если они существуют

  

```SQL
SELECT customers.customer_name, orders.order_date
FROM customers
LEFT JOIN orders ON customers.customer_id = orders.customer_id;

```

Результатом этого запроса будет таблица, в которой будут перечислены все имена клиентов из таблицы `customers`, а также даты заказов, если они есть. Если для клиента нет заказов, то значение в столбце `order_date` будет `NULL`. Таким образом, результат будет таким:

|   |   |
|---|---|
|customer_name|order_date|
|John|2022-04-15|
|John|2022-04-17|
|Emily|2022-04-16|
|Michael|2022-04-18|
|Sarah|NULL|
|David|NULL|

  

### RIGHT JOIN

В запросе ниже мы используем `RIGHT JOIN`, чтобы выбрать все записи из таблицы `orders`, а также связанные с ней записи из таблицы `customers`, если они существуют:

```SQL
SELECT customers.customer_name, orders.order_date
FROM customers
RIGHT JOIN orders ON customers.customer_id = orders.customer_id;
```

Результатом этого запроса будет таблица, в которой будут перечислены все даты заказов из таблицы `orders`, а также имена клиентов, если они есть. Если для заказа нет соответствующего клиента, то значение в столбце `customer_name` будет `NULL`. Таким образом, результат будет таким:

|   |   |
|---|---|
|customer_name|order_date|
|John|2022-04-15|
|Emily|2022-04-16|
|John|2022-04-17|
|Michael|2022-04-18|
|NULL|2022-04-19|

### FULL JOIN

```SQL
SELECT customers.customer_name, orders.order_date
FROM customers
FULL JOIN orders ON customers.customer_id = orders.customer_id;
```

Результатом этого запроса будет таблица, содержащая все имена клиентов и даты заказов, при этом значения будут `NULL`, если для них нет соответствующей записи в другой таблице. Таким образом, результат будет таким:

|   |   |
|---|---|
|customer_name|order_date|
|John|2022-04-15|
|John|2022-04-17|
|Emily|2022-04-16|
|Michael|2022-04-18|
|Sarah|NULL|
|David|NULL|
|NULL|2022-04-19|

## Индексы, B-Tree

![[images/Untitled 22 3.png|Untitled 22 3.png]]

![[images/Untitled 23 3.png|Untitled 23 3.png]]

### Создание индексов

Плюсы:

Ускоряет поиск по БД

  

Минусы:

Занимают память

Замедляют операции изменение данных

Реиндексация при кластерных индексах

  

Создание индекса для одного столбца.

В этом примере мы создаем индекс с именем `idx_name` для столбца `name` в таблице `products`. Этот индекс ускорит выполнение запросов на выборку данных по значению столбца `name`.

```SQL
CREATE INDEX idx_name ON products (name);
```

Создание индекса для нескольких столбцов.

В этом примере мы создаем индекс с именем `idx_name_code` для столбцов `name` и `code` в таблице `products`. Этот индекс ускорит выполнение запросов на выборку данных по значениям столбцов `name` и `code` вместе.

```SQL
CREATE UNIQUE INDEX idx_code ON products (code);
```

Создание уникального индекса

В этом примере мы создаем уникальный индекс с именем `idx_code` для столбца `code` в таблице `products`. Этот индекс гарантирует, что значения в столбце `code` будут уникальными и ускорит выполнение запросов на выборку данных по значению столбца `code`.

```SQL
CREATE UNIQUE INDEX idx_code ON products (code);
```

- ==**Cоставной**== ==индекс== `ограничен` ==`16`== ==столбцами== или `==900==` ==байтами==

  

### Виды индексов под капотом

1. ==**B-деревья (B-trees)**====:==
    - B-деревья являются одним из наиболее распространенных и эффективных алгоритмов индексации в базах данных.
    - Они обеспечивают эффективный поиск, вставку и удаление элементов в индексе.
    - B-деревья поддерживают сбалансированное дерево, которое позволяет быстро найти нужный элемент, используя логарифмическое время.
    - B-деревья широко используются для индексации в различных СУБД, таких как PostgreSQL, MySQL, Oracle и других.
2. ==**B+ деревья (B+-trees)**====:==
    
    - B+ деревья являются вариацией B-деревьев и также широко используются для индексации в базах данных.
    - В отличие от B-деревьев, B+ деревья хранят ключи только в листовых узлах, что делает их более эффективными для поиска.
    - B+ деревья обеспечивают хорошую поддержку для диапазонных запросов.
    - Этот тип индексации также широко применяется в различных СУБД.
    
    Вот пример простой схемы B+ дерева с тремя уровнями (корень, внутренние узлы, листовые узлы):
    
    ```CSS
                    [ K1, K2, K3 ]
                     /     |       \
                   /       |        \
           [ K1 ]         [ K2 ]       [ K3 ]
          /  |  \        /  |  \      /  |  \
      /    |     \    /     |     \  /    |    \
    [L1] [L2] [L3] [L4] [L5] [L6] [L7] [L8] [L9]
    
    ```
    
    - `**K1**`, `**K2**`, `**K3**`: ключи внутренних узлов.
    - `**L1**` до `**L9**`: данные (или ссылки на данные) в листовых узлах.
    
    Ключевая особенность здесь заключается в том, что данные хранятся только в листовых узлах, а внутренние узлы служат для направления поиска.
    
3. ==**Хеш-индексы (Hash indexes)**====:==
    - Хеш-индексы используют хеш-функции для быстрого поиска ключей.
    - Они обеспечивают очень быстрый поиск, но могут быть менее эффективными для диапазонных запросов.
    - Хеш-индексы часто используются для индексации в памяти или для индексации столбцов с высокой степенью уникальности значений.
4. ==**GiST (Generalized Search Tree)**====:==
    
    - GiST - это обобщенное дерево поиска, которое позволяет определять собственные типы данных и методы поиска.
    - Он предоставляет гибкую индексацию для различных типов данных, таких как географические данные, полнотекстовый поиск и другие.
    
    1. **GIST (Generalized Search Tree)**:
        - GIST является обобщенной структурой данных, которая может хранить произвольные типы данных и поддерживать произвольные типы запросов на поиск и сравнение.
        - GIST может использоваться для индексации данных, которые не могут быть эффективно обработаны стандартными структурами данных, такими как B-деревья.
        - GIST поддерживает несколько типов операций поиска и сравнения, включая операции на основе расстояния и условные операции.
        - Примеры использования GIST включают пространственные индексы (например, для географических данных) и индексы для полнотекстового поиска.
    2. **B-деревья (B-trees)**:
        - B-деревья являются структурой данных, оптимизированной для индексации и поиска данных в базах данных.
        - Они предназначены для индексации ключей и обычно используются для индексации значений в базах данных, таких как строки или числа.
        - B-деревья хранят ключи в упорядоченном виде и обеспечивают эффективную поддержку операций вставки, удаления и поиска.
        - Основное применение B-деревьев - это индексация данных в базах данных для ускорения операций выборки данных.
    
    Вот пример обобщенного дерева поиска GIST и B-дерева:
    
    ```VB.Net
    vbnetCopy code
                         GIST Tree
              /               |               \
         /             |              \
    Spatial Data      Text Search      Custom
      Index            Index           Index
    
    
                       B-tree
              /               |               \
         /             |              \
    Keys in Order    Keys in Order    Keys in Order
       with            with            with
       Pointers        Pointers        Pointers
    
    ```
    
    На этом изображении:
    
    - В GIST Tree узлы могут быть индексированы различными способами, включая пространственные данные, полнотекстовый поиск и другие пользовательские типы данных.
    - В B-tree узлы содержат ключи в упорядоченном виде, а каждый ключ сопровождается указателем на соответствующие данные.
5. ==**GIN (Generalized Inverted Index)**====:==
    - GIN - это обобщенный инвертированный индекс, который часто используется для индексации списков или массивов.
    - Он предоставляет эффективный поиск по значениям, содержащимся в таких структурах данных.

### USING

1. B-tree индекс с оператором `USING`:

```Plain
CREATE INDEX idx_name ON products USING BTREE (name);

```

В этом примере мы создаем B-tree индекс с именем `idx_name` для столбца `name` в таблице `products`. Оператор `USING` используется для явного указания типа индекса, в данном случае B-tree. Этот тип индекса эффективен для поиска точных значений, сравнения диапазонов и сортировки данных.

1. GIN индекс с оператором `USING`:

```Plain
CREATE INDEX idx_tags ON products USING GIN (tags);

```

В этом примере мы создаем GIN индекс с именем `idx_tags` для столбца `tags` в таблице `products`. Оператор `USING` используется для явного указания типа индекса, в данном случае GIN. Этот тип индекса оптимизирован для поиска в массивах или списковых структурах данных.

1. BRIN индекс с оператором `USING`:

```Plain
CREATE INDEX idx_sales ON orders USING BRIN (sale_date);

```

В этом примере мы создаем BRIN индекс с именем `idx_sales` для столбца `sale_date` в таблице `orders`. Оператор `USING` используется для явного указания типа индекса, в данном случае BRIN. Этот тип индекса эффективен для больших таблиц, которые хранят данные в определенном порядке, например, временных рядах или геоданных.

1. GiST индекс с оператором `USING`:

```Plain
CREATE INDEX idx_points ON locations USING GiST (point);

```

В этом примере мы создаем GiST индекс с именем `idx_points` для столбца `point` в таблице `locations`. Оператор `USING` используется для явного указания типа индекса, в данном случае GiST. Этот тип индекса оптимизирован для поиска в геоданных и других типах сложных структур данных.

1. SP-GiST индекс с оператором `USING`:

```Plain
CREATE INDEX idx_polygons ON areas USING SPGIST (polygon);

```

В этом примере мы создаем SP-GiST индекс с именем `idx_polygons` для столбца `polygon` в таблице `areas`. Оператор `USING` используется для явного указания типа индекса, в данном случае SP-GiST. Этот тип индекса оптимизирован для поиска в сложных геометрических структурах

### Создание частичного, на выражение, на функцию, с опцией сортировки

1. Создание частичного индекса:

```SQL
CREATE INDEX idx_active_products ON products (id) WHERE active = true;
```

В этом примере мы создаем частичный индекс с именем `idx_active_products` для столбца `id` в таблице `products`, который будет содержать только активные записи. Этот тип индекса может быть полезен для ускорения запросов, которые фильтруют данные по условиям, включающим только часть таблицы.

1. Создание индекса на вычисляемое выражение:

```SQL
CREATE INDEX idx_total_price ON orders (total_price / quantity);
```

В этом примере мы создаем индекс с именем `idx_total_price` для вычисляемого выражения `total_price / quantity` в таблице `orders`. Этот тип индекса может быть полезен для ускорения запросов на выборку данных, которые используют вычисляемые выражения в качестве фильтров или сортировок.

1. Создание индекса на функцию:

```SQL
CREATE INDEX idx_upper_name ON products (UPPER(name));
```

В этом примере мы создаем индекс с именем `idx_upper_name` для значения столбца `name`, приведенного к верхнему регистру с помощью функции `UPPER()`. Этот тип индекса может быть полезен для ускорения запросов на выборку данных, которые используют функции в качестве фильтров или сортировок.

1. Создание индекса с опцией сортировки:

```SQL
CREATE INDEX idx_name_desc ON products (name DESC);
```

В этом примере мы создаем индекс с именем `idx_name_desc` для столбца `name` в таблице `products`, отсортированного в обратном порядке. Этот тип индекса может быть полезен для ускорения запросов на выборку данных, которые используют сортировку по убыванию.

### Кластерный и обычный индекс

Предположим, у нас есть база данных, которая хранит информацию о книгах в библиотеке. Давайте рассмотрим пример с использованием кластерного и обычного (некластеризованного) индексов.

Предположим, у нас есть таблица `**Books**`, содержащая информацию о книгах. Пусть у этой таблицы есть столбцы:

- `**BookID**` (идентификатор книги),
- `**Title**` (название книги),
- `**Author**` (автор книги),
- `**Genre**` (жанр книги).

**Пример с кластерным индексом:**

Предположим, мы решаем сделать индекс по столбцу `**Author**`. Мы делаем этот индекс кластерным.

В этом случае, книги в таблице `**Books**` будут физически упорядочены по авторам. Например:

```Markdown

BookID | Title           | Author        | Genre
-----------------------------------------------
1      | Book1           | AuthorA       | Fiction
2      | Book2           | AuthorB       | Non-Fiction
3      | Book3           | AuthorB       | Fiction
4      | Book4           | AuthorC       | Mystery
5      | Book5           | AuthorD       | Biography

```

Здесь мы видим, что книги упорядочены по столбцу `**Author**`. Это значит, что все книги автора A будут идти первыми, затем книги автора B и так далее.

**Пример с обычным (некластеризованным) индексом:**

Предположим, мы решаем сделать обычный индекс по столбцу `**Genre**`.

В этом случае, индекс будет указывать, где находятся книги разных жанров в таблице, но сама таблица `**Books**` останется неупорядоченной по жанру. Например:

```Markdown

BookID | Title           | Author        | Genre
-----------------------------------------------
1      | Book1           | AuthorA       | Fiction
2      | Book2           | AuthorB       | Non-Fiction
3      | Book3           | AuthorB       | Fiction
4      | Book4           | AuthorC       | Mystery
5      | Book5           | AuthorD       | Biography

```

Здесь индекс по жанру будет указывать, например, что все книги жанра "Fiction" находятся на строках с ID 1 и 3, но порядок строк в таблице не будет зависеть от жанра книги.

Таким образом, кластерный индекс изменяет физический порядок хранения строк в таблице, в то время как обычный индекс только указывает на их местоположение.

  

По умолчанию PostgreSQL создает кластерный индекс (CLUSTER) для первичного ключа. Это означает, что если вы определяете столбец как первичный ключ (PRIMARY KEY) при создании таблицы, PostgreSQL автоматически создает кластерный индекс для этого столбца.

Например:

```SQL
sqlCopy code
CREATE TABLE Books (
    BookID SERIAL PRIMARY KEY,
    Title VARCHAR(255),
    Author VARCHAR(255),
    Genre VARCHAR(50)
);

```

В этом примере столбец `**BookID**` определен как первичный ключ с помощью ключевого слова `**PRIMARY KEY**`. PostgreSQL автоматически создаст кластерный индекс для столбца `**BookID**`, который будет определять фактический порядок хранения строк в таблице.

### Вопросы

### ==**Можно ли создать кластеризованный индекс на столбце, содержащем дубликаты?**==

`И да, и нет.` Да ==вы можете создать кластеризованный индекс на ключевом столбце, содержащем дубликаты значений. Нет, значение ключевого столбца не смогут остаться в состоянии не уникальности==. Позвольте объяснить. Если вы создаёте неуникальный кластерный индекс (non-unique clustered index) на столбце, то подсистема хранения данных добавляет к дублирующему значению целочисленное значение (uniquifier), чтобы удостовериться в уникальности и, соответственно, обеспечить возможность идентифицировать каждую строку в кластеризованной таблице.

К примеру, вы можете решить создать в таблице с данными о клиентах кластеризованный индекс по столбцу

_LastName_, хранящим фамилию. Столбец содержит такие значения как Franklin, Hancock, Washington и Smith. Затем вы вставляете значения Adams, Hancock, Smith и снова Smith. Но значение ключевого столбца обязательно должны быть уникальны, поэтому подсистема хранения данных изменит значение дубликатов таким образом, что ==они будут выглядеть примерно так: Adams, Franklin, Hancock, Hancock1234, Washington, Smith, Smith4567 и Smith5678.==

На первый взгляд такой подход кажется нормальным, но целочисленное значение увеличивает размер ключа, что может стать проблемой при большом количестве дубликатов, а эти значения станут основой некластеризованного индекса или ссылкой внешнего ключа. По этим причинам вы всегда должны стараться создавать уникальный кластеризованный (unique clustered indexes) при любой возможности. Если это невозможно, то по крайней мере постарайтесь использовать столбцы с очень высоким содержание уникальных значений.

## План выполнения Explan

### Теория

- Сейчас ==есть только стоимостной==
- Определяет `page_cost` —> ==сколько сегментов нужно считать== ==на жестком диске==
- `cpu_cost` - цена процессора, сколько у нас ==записей в таблице==
- Всё можно найти в pg_class
- `Seq Scan - вся таблица пройдена`
- `width` - ==вес строки==

![[images/Untitled 24 3.png|Untitled 24 3.png]]

![[images/Untitled 25 3.png|Untitled 25 3.png]]

![[images/Untitled 26 3.png|Untitled 26 3.png]]

### План выполнения: Индексы

![[images/Untitled 27 3.png|Untitled 27 3.png]]

  

![[images/Untitled 28 3.png|Untitled 28 3.png]]

  

![[images/Untitled 29 3.png|Untitled 29 3.png]]

![[images/Untitled 30 3.png|Untitled 30 3.png]]

- `Для разных индексов`

![[images/Untitled 31 3.png|Untitled 31 3.png]]

![[images/Untitled 32 3.png|Untitled 32 3.png]]

  

## Триггеры

`Триггеры` — это ==части кода, запускаемые автоматически и основанные==

==на каком-либо действии или событии в таблице базы данных.==

Триггеры могут применять в таблице во время выполнения операторов

`INSERT, UPDATE или DELETE`, а ==затем работать или перед, или после этих действий.==

Некоторые СУБД также позволяют работать триггерам на уровне оператора

или на уровне каждой строки данных во время ее изменения.

`Триггеры событий`

С точки зрения событий триггеры можно разделить на 3 группы.

1. ==BEFORE== (до выполнения операции);
2. ==INSTEAD OF== (вместо выполнения операции);
3. ==AFTER== (после выполнения операции).

`Уровень работы триггеров`

- триггеры ==уровня строки(row)== запускаются каждый раз заново для каждой отдельной строки (записи таблицы), которая будет затронута SQL-запросом;
- триггеры ==уровня запроса(statement)== запускаются один раз для всего SQL-запроса.

![[images/Untitled 33 3.png|Untitled 33 3.png]]

## DWH

![[images/Untitled 34 3.png|Untitled 34 3.png]]

![[images/Untitled 35 3.png|Untitled 35 3.png]]

![[images/Untitled 36 3.png|Untitled 36 3.png]]

![[images/Untitled 37 3.png|Untitled 37 3.png]]

![[images/Untitled 38 3.png|Untitled 38 3.png]]

![[images/Untitled 39 3.png|Untitled 39 3.png]]

![[images/Untitled 40 3.png|Untitled 40 3.png]]

## Теорема CAP / NoSql

![[images/Untitled 41 3.png|Untitled 41 3.png]]

![[images/Untitled 42 3.png|Untitled 42 3.png]]

![[images/Untitled 43 3.png|Untitled 43 3.png]]

![[images/Untitled 44 3.png|Untitled 44 3.png]]

![[images/Untitled 45 3.png|Untitled 45 3.png]]

![[images/Untitled 46 3.png|Untitled 46 3.png]]

![[images/Untitled 47 3.png|Untitled 47 3.png]]

![[images/Untitled 48 3.png|Untitled 48 3.png]]

![[images/Untitled 49 3.png|Untitled 49 3.png]]

  

## Транзакции

`Транзакция` - это ==_единица работы в рамках соединения с базой данных_==, либо выполняется полностью `COMMIT`, либо полностью откатывается `ROLLBACK`

### ACID

`ACID` - это акроним от атомарности (Atomicity), согласованности (Consistency), изолированности (Isolation) и долговечности (Durability). ==Эти свойства обеспечивают целостность данных и надежность транзакций в базах данных.==

- `Атомарность (Atomicity)` означает, что ==транзакции должны быть выполнены полностью или не выполнены вовсе==. Если происходит ==ошибка во время транзакции, то все изменения должны быть отменены==, чтобы сохранить целостность базы данных.
- `Согласованность (Consistency)` ==гарантирует, что база данных всегда будет находиться в правильном состоянии после завершения транзакции.== Если ==транзакция не может быть завершена, то база данных должна быть возвращена к своему предыдущему состоянию.==
- `Изолированность (Isolation)` ==гарантирует, что транзакции, выполняемые одновременно, не будут взаимно влиять друг на друга.== Это означает, что ==результаты одной транзакции не должны быть видны другим транзакциям==, пока первая транзакция не будет завершена.
- `Долговечность (Durability)` гарантирует, что ==изменения в базе данных, выполненные в рамках транзакции, будут сохранены== и **==не будут потеряны в случае сбоя==** системы.

### Проблемы при работе с транзакциями

`Проблемы изоляции транзакций возникают,` когда ==две или более транзакции пытаются получить доступ к одним и тем же данным в базе данных одновременно.== Эти ==проблемы связаны с тем, что одна транзакция может видеть изменения, которые еще не были завершены другой транзакцией, что может привести к неправильным результатам и ошибкам в базе данных.==

Существует несколько проблем изоляции транзакций, которые могут возникнуть в базе данных.

1. `Lost update -` потерянное обновление: Эта проблема возникает, когда ==две или более транзакции пытаются изменить одну и ту же запись в базе данных одновременно==. Если одна транзакция изменяет запись первой, а другая транзакция изменяет ту же запись позже, то изменения первой транзакции будут потеряны. (`УЖЕ РЕШЕНА В СОВРЕМЕННЫХ СУБД)`

![[images/Untitled 50 3.png|Untitled 50 3.png]]

1. `Dirty read` - грязное чтение: Эта проблема возникает, когда ==одна транзакция читает данные, которые были изменены другой транзакцией, но еще не были подтверждены (commit)==. Если вторая транзакция откатывается (rollback), то данные, прочитанные из базы данных, будут неверными

![[images/Untitled 51 3.png|Untitled 51 3.png]]

1. `Non-repeatable read` - неповторяемое чтение: Эта проблема возникает, когда ==одна транзакция читает данные из базы данных, а затем другая транзакция обновляет (update) эти данные и подтверждает свои изменения==. Если первая транзакция попытается прочитать эти данные еще раз, она получит другой результат.

![[images/Untitled 52 3.png|Untitled 52 3.png]]

  
  
`Частный случай last commit wins:`  
Подход "last commit wins" предполагает, что если  
==одна транзакция изменяет данные, которые были прочитаны другой транзакцией, то последние изменения должны быть сохранены в базе данных, а изменения, сделанные первой транзакцией, будут потеряны.==

![[images/Untitled 53 3.png|Untitled 53 3.png]]

1. `Phantom read -` призрачное чтение: Эта проблема возникает, когда ==одна транзакция выполняет запрос на чтение и получает набор результатов, а затем другая транзакция вставляет, обновляет или удаляет данные, которые соответствуют этому запросу, и подтверждает свои изменения. Если первая транзакция выполняет этот же запрос еще раз, она получит другой набор результатов.==

![[images/Untitled 54 3.png|Untitled 54 3.png]]

Чтобы ==избежать этих проблем, необходимо использовать правильный уровень изоляции транзакций в базе данных, который обеспечит правильное управление параллельным доступом к данным и избежание конфликтов==. Разные СУБД могут предоставлять различные уровни изоляции, такие как `READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ и SERIALIZABLE.`

- в PG - либо `READ COMMITTED` по умолчанию, либо `SERIALIZABLE`

![[images/Untitled 55 3.png|Untitled 55 3.png]]

### Propagation

1. `**REQUIRED**`:
    
    ```Java
    
    @Transactional(propagation = Propagation.REQUIRED)
    public void methodA() {
        // Логика работы с базой данных
    }
    
    ```
    
    _Пример использования_: Если вызванный метод `**methodA()**` вызывается из другого метода, который уже работает в рамках транзакции, `**methodA()**` будет использовать эту же транзакцию. Если же вызывающий метод не находится в транзакционном контексте, будет создана новая транзакция.
    
2. `**REQUIRES_NEW**`:
    
    ```Java
    
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void methodB() {
        // Логика работы с базой данных
    }
    
    ```
    
    _Пример использования_: Метод `**methodB()**` всегда будет выполняться в собственной транзакции. Даже если он вызывается из метода, который уже работает в рамках транзакции, транзакция внешнего метода будет приостановлена, и `**methodB()**` будет выполняться в новой транзакции. Это полезно, когда вам нужно изолировать операции в базе данных в новой транзакции, чтобы гарантировать их атомарность и независимость.
    
3. `**SUPPORTS**`:
    
    ```Java
    
    @Transactional(propagation = Propagation.SUPPORTS)
    public void methodC() {
        // Логика работы с базой данных
    }
    
    ```
    
    _Пример использования_: Метод `**methodC()**` будет использовать активную транзакцию, если таковая имеется. Если вызывающий метод не находится в транзакционном контексте, `**methodC()**` будет выполняться без транзакционного контекста. Это может быть полезно, если метод может быть вызван как из транзакционного, так и из непривязанного к транзакции контекста.
    
4. `**MANDATORY**`:
    
    ```Java
    
    @Transactional(propagation = Propagation.MANDATORY)
    public void methodD() {
        // Логика работы с базой данных
    }
    
    ```
    
    _Пример использования_: Метод `**methodD()**` требует наличия активной транзакции. Если он вызывается из контекста без активной транзакции, будет сгенерировано исключение. Это полезно, когда метод должен быть вызван только в рамках уже существующей транзакции.
    
5. `**NESTED**`:
    
    ```Java
    
    @Transactional(propagation = Propagation.NESTED)
    public void methodE() {
        // Логика работы с базой данных
    }
    
    ```
    
    _Пример использования_: Метод `**methodE()**` создает вложенную транзакцию, которая является подчиненной главной транзакции. Если вложенная транзакция завершается успешно, она фиксируется. Если главная транзакция завершается неудачно, вложенная транзакция откатывается. Это полезно, когда вам нужно иметь вложенные транзакции с определенной степенью изоляции и атомарности.
    
6. `**NOT_SUPPORTED**`:
    
    ```Java
    
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    public void methodF() {
        // Логика работы с базой данных
    }
    
    ```
    
    _Пример использования_: Метод `**methodF()**` будет выполняться без транзакционного контекста. Если в момент вызова метода существует активная транзакция, она будет приостановлена до завершения метода. Это может быть полезно, если нужно выполнить операции без транзакционной защиты.
    
7. `**NEVER**`:
    
    ```Java
    
    @Transactional(propagation = Propagation.NEVER)
    public void methodG() {
        // Логика работы с базой данных
    }
    ```
    
    _Пример использования_: Метод `**methodG()**` не должен быть выполнен в контексте транзакции. Если при вызове метода существует активная транзакция, будет сгенерировано исключение. Это может быть полезно, когда вы хотите гарантировать, что метод не выполняется в рамках транзакции.
    
      
    

В этом примере метод `**deleteFileAndRecord()**` не использует аннотацию `**@Transactional**`, и это безопасно, потому что удаление файла из файловой системы и удаление соответствующей записи из базы данных - это атомарные операции, они либо обе выполняются успешно, либо ни одна из них. Таким образом, использование транзакции в этом случае не требуется и может быть избыточным, приводя к ненужным накладным расходам и увеличению нагрузки на базу данных.

Однако, если удаление файла и/или записи в базе данных зависит от других операций, которые должны быть атомарными (например, удаление файла должно быть отменено, если удаление записи из базы данных не удалось), тогда использование транзакции может быть необходимо.

### Интересные моменты

![[images/Untitled 56 3.png|Untitled 56 3.png]]