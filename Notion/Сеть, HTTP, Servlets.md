---
modified: 2024-09-11T14:07:20+03:00
---
Курс - [https://www.asozykin.ru/courses/networks_online](https://www.asozykin.ru/courses/networks_online)

Конспект - [https://zinvapel.github.io/it/network/2017/11/13/sozykin/](https://zinvapel.github.io/it/network/2017/11/13/sozykin/)

![[images/Untitled 17.png|Untitled 17.png]]

### Модель OSI (Теория)

Open System Interconnection model - эталонная модель взаимодействия открытых систем, которая лежит в основе всех стандартов компьютерных сетей.

![[images/Untitled 1 6.png|Untitled 1 6.png]]

### Уровни

![[images/Untitled 2 5.png|Untitled 2 5.png]]

### Прикладной уровень

Обеспечивает связь между приложениями

Единственный уровень, который напрямую взаимодействует с данными от пользователей

Протоколы прикладного уровня `HTTP, FTP, SMTP, SSH` и другие

![[images/Untitled 3 5.png|Untitled 3 5.png]]

### Уровень представления

Presentation layer - основная задача этого уровня заключается в преобразовании передаваемх данных во взаимно согласованные форматы, шифровании, компрессии данных и обратные этим процессам, дешифрование, декомпрессия и тд.

Протоколы - TSL, SSL

![[images/Untitled 4 5.png|Untitled 4 5.png]]

### Сеансовый уровень

организует сеансы связи между устройствами, позволяя взаимодействовать длительное время

Другими словам, ответственный за открытие и закрытие соединений ( сессия - это и есть время между открытием и закрытием соединения между устройствами)

На практике протоколы сенасового уровня не выделяются, их работу выполняют протоколы верхних уровней

![[images/Untitled 5 5.png|Untitled 5 5.png]]

### Транспортный уровень

Разбивает поток данных на сегменты для передачи на сетевой уровень( и наоборот, склеивает пакеты из сетевого уровня в сегменты), добавляя свой заголовок к каждому сегменту (порты приложений), а также выполняет процедуры для обеспечения необходимого уровня надежности передачи информации.

![[images/Untitled 6 4.png|Untitled 6 4.png]]

### Основные протоколы TCP, UDP

Порт в контексте TCP (Transmission Control Protocol) и UDP (User Datagram Protocol) является числовым идентификатором, который используется для определения конечной точки коммуникации в сетевом приложении. Каждое сетевое приложение на устройстве, подключенном к сети, может использовать порт для обмена данными с другими устройствами.

![[images/Untitled 7 4.png|Untitled 7 4.png]]

_Время между открытием и закрытием соединения - сессия._

  

TCP и UDP — это два наиболее распространенных протокола транспортного уровня, которые обеспечивают доставку данных в компьютерных сетях. Они используют порты для обеспечения правильной доставки данных на конкретное приложение или службу.

В TCP/IP каждый порт представлен 16-битным числом (от 0 до 65535). Порты до 1024 называются известными портами (well-known ports) и зарезервированы для широко известных служб, таких как веб-серверы (порт 80 для HTTP, порт 443 для HTTPS), почтовые серверы (порт 25 для SMTP, порт 110 для POP3) и другие.

Порты от 1024 до 49151 называются зарегистрированными портами (registered ports) и могут быть использованы различными приложениями и службами, не являющимися широкоизвестными.

Порты от 49152 до 65535 называются динамическими или частными портами (dynamic/private ports). Они используются операционной системой для временных соединений и не связаны с конкретными службами.

Протокол TCP обеспечивает надежную, установленную и ориентированную на соединение передачу данных. Он использует порты для установления соединения между двумя конечными точками (IP-адресами) и обмена данными в рамках этого соединения.

UDP является протоколом без установления соединения и не гарантирует доставку данных. Он также использует порты для идентификации приложений, но каждый пакет данных отправляется независимо и может быть доставлен в любом порядке или потерян без уведомления.

Примеры использования UDP:

Там где файлы могут не доставиться( скайп звонок, ютуб).

Появляется возможность запускать на одной машине несколько приложений с доступом в сеть по шаблону IP: Port : `127.0.0.8080`

### Сетевой уровень

Главной задачей является разбиение сегментов с предыдущего уровня на пакеты данных ( и наооборот, пакеты собирать в сегменты для отправки на следующий уровень), а также доставка этих пакетов данных между разными сетями.  
Основной протокол сетевого уровня -  
`IP (Internet Protocol)`

![[images/Untitled 8 4.png|Untitled 8 4.png]]

На данной картинке показано, что сетевой уровень принимает из транспортного уровня (TL) и добавляет к метаинформации свой заголовок, предварительно разбивая сегмент на пакеты.

Для решения этой задачи вводится своя система адресации ( сетевой адрес IP4 или IPv6) и реализуется механизм маршрутизации ( определение пути передачи данных между сетями. Маршрутизатор == роутер.

Ip адреса должны быть униакальны в пределах всей сети Internet.

  

### IP aдрес (v4)

32 битное число, которое принято записывать 4 октетами, каждый октет разделен точкой и занимает ровно 8 бит и может принимать значения от 0 до 255. `192.168.0.1` , `172.217.16.4`

![[images/Untitled 9 4.png|Untitled 9 4.png]]

![[images/Untitled 10 3.png|Untitled 10 3.png]]

![[images/Untitled 11 3.png|Untitled 11 3.png]]

![[images/Untitled 12 3.png|Untitled 12 3.png]]

![[images/Untitled 13 3.png|Untitled 13 3.png]]

![[images/Untitled 14 2.png|Untitled 14 2.png]]

### IP aдрес (v6)

это 128-битное число, которое принято записывать в виде 8 четырезначных шестнадцатеричных чисел, разделенных двоеточием `2001:0db8:0000:0000:0000:ff00:0042:7879` , `2001:0db8`**`::`**`ff00:0042:7879`, нули могут опускаться двумя двоеточиями.

  

Наряду с public IP адресами существуют private IP адреса, которые можно самостоятельно назначать в локальных сетях, в таком случае доступ в глобальную сеть Internet осуществляется на основе NAT (Network Address Translation) или Proxy.

Диапазоны private IP адресов:

10.0.0.0 - 10.255.255.255

172.16.0.0 - 172.31.255.255

192.168.0.0 - 192.168.255.255

  

### Сетевая маска

Ip адреса недостаточно для определния сети, в которой находится компьюер.

Для определения адреса сети используется дополнительное 32-битное число - сетевая маска. Помогает определять в какой подсети находится наше устройство.

![[images/Untitled 15 2.png|Untitled 15 2.png]]

![[images/Untitled 16 2.png|Untitled 16 2.png]]

При отправке данных получателю 1 от отправителя не увидим трафика, так как адрес сети( первые три октета) совпадает, значит они находятся в одной подсети. А получатель 2 находится уже в другой сети( 3 октет не совпадает), придется задействовать маршрутизатор, чтобы перенаправить наши IP пакеты в другую сеть.

![[images/Untitled 17 2.png|Untitled 17 2.png]]

### Канальный уровень

Data link layer разбиваются пакеты с предыдущего уровня на кадры (frame) данных ( и наооборот, кадры преобразуются в пакеты) и производится доставка кадров в пределах одной сети, осуществляется проверка доступности среды передачи и контроль ошибок передачи.  
Основные протоколы транспортного уровня  
`Ethernet, PPP(Point to Point Protocol), PPpoE(разновидность Point to Point Protocol)`

![[Untitled 18.png]]

![[Untitled 19.png]]

![[Untitled 20.png]]

![[Untitled 21.png]]

### Физический уровень

Реализован аппаратно и определяет методы передачи битов данных по физическим каналам.

Описываются такие характеристики как вид среды передачи(кабель или радиоэфир), топологии сети и другие

![[Untitled 22.png]]

### DNS

Доменное имя представляет из себя понятный и хорошо запоминающийся человеку текст, например google.com

С каждым доменным именем связывается один или несколько IP адресов, и в свою очередь, с каждым IP адресом может быть связано одно или несколько доменных имен.

Cуществуют два способа реализации системы доменных имен:

1. был основан на использовании файла hosts, который представляет из себя обычный текстовый файл, где хранятся пары соответствий IP адресов и доменных имен.
    
    Windows - `C:\windows\system32\drivers\etc\hosts`
    
    Unix - `/etc/hosts`
    
2. Второй способ реализации доменных имен основан на использовании службы DNS  
    DNS (Domain Name System) - это распределенная система, в которой информация о доменах хранится на большом количестве связанных между собой DNS-серверов.  
    

Каждый DNS-сервер хранит информацию о доменах только своей зоны

Но т.к. все DNS серверы связаны между собой, то можно получить необходимую информацию( т.е. IP адрес по доменному имени) вне зависимости от того, к какому серверу вы обратились.

DNS предполагает, что все компьютеры в сети разделяются на логические группы - домены.

При этом доменные имена образуют иерархическую структуру, т.к одни домены могут являться частью других

В этой связи выделяют домены первого уровня, второго и т.д.

![[Untitled 23.png]]

Переход с домена на домен осуществляется справа-налево

![[Untitled 24.png]]

Обычно DNS используется для преобразования доменных имен в IP адреса - это называется прямое преобразование.

Обратное преобразование - по известному IP адресу получить доменное имя.

Для обратного преобразования в DNS используются обратные зоны, которые создаются и настраиваются независимо от прямых.

Созданием и поддержанием имен в доменах верхнего уровня занимаются спцеиальные компании - регистраторы доменных имен.

Сами домены верхнего уровня создаются и поддерживаются на уровне корневого домена. Этим занимается международная организация.

### HTTP

### Общая информация

HyperText Transfer Protocol - протокол передачи произвольных данных прикладного уровня, который изначально был предназначен для передачи только HTML (HYPER TEXT MARKUP LANGUAGE) документов. Сейчас отношение к гипертексту не имеет.

Протокол соответствует клиент-серверной архитектуре, где взаимодействие и клиента и веб-сервера осуществляется по стандартной схеме `request-response`

![[Untitled 25.png]]

Каждое HTTP-сообщение, независимо от того, следует оно от клиенту к серверу (request) или от сервера к клиенту (response), состоит трех основных частей:

1. Стартовая строка - определяет тип сообщения, в которой указываются следующие данные(general):
    
    1. `Request`:
    
    - метод (GET, POST, PUT. DELETE. etc) - название операции, которая должна быть выполнена HTTP запросом (request)
    - адрес (URL) - Unfiormj Resourse Locator состоит из 4 основных частей :
        - протокол
        - доменное имя или IP адрес (с портом)
        - адрес ресурса (по указанному доменному имени или IP адресу)
        - список параметров
        - ==`https://`====`www.examle.com:443`====`/users/1`====`?word=java&sourseid=chrome`==
    - версия протокола (HHTP”/1.1, HTTP/2)
    
    b. `Response`:
    
    - версия протокола (HTTP/1.1, HTTP/2)
    - код состояния  
        Код состояни (status code) - цифровой код ответа сервера, состоящий ищ трехзначного числа, первая цифра которого означает класс состояния.  
        
        ![[Untitled 26.png]]
        
        - 1xx - информация о состоянии процесса передачи  
            101 Continue  
            101 Switching protocols  
            
        - 2xx - информация об успешном запросе и его обработке  
            200 OK (get запрос)  
            201 Created (Created)  
            204 No content( delete запрос)  
            
        - 3xx - информация о том, что необходимо выполнить запрос по другому адресу, указанному в заголовке location(header)  
            301 Moved permanentl  
            302 Moved temporarily  
            
        - 4xx - информация об ошибках со стороны клиента  
            401 Unathorized  
            403 Forbidden  
            404 Not found  
            
        - 5xx информация об ошибках на стороне сервера  
            500 Internal Server Error  
            503 Service Unavailable  
            504 Gateway Timeout  
              
            
    - текстовое пояснение
    
    ![[Untitled 27.png]]
    
2. Заголовок(header)  
    Характеризует тело сообщения body и параметры его передачи в ваиде “header_name: header_value”  
    Другими словами, является метаинформацией HTTP сообщения (названия заголовков не чувствительны к регистру)  
    

![[Untitled 28.png]]

1. Тело сообщения (body) - это непосредственно пересылаемые данные HTTP сообщением. Отделяется от заголовка пустой строкой. Сами данные могут быть любые: HTML страницы, JSON, XML, видео, картинки, файлы

![[Untitled 29.png]]

### HTTP/2

Главные отличия от HTTP/1.1 :

- ==Бинарный вместо текстового==  
      
    ==Бинарные сообщения быстрее разбираются автоматически, представляяя из себя== ==фреймы и потоки.== ==Но в отличие от тектовых, не понятны для чтения человеком.==  
    Переходом на бинарный формат, HTTP/2 пытается решить проблему выросшей задержки (latency)  
    
    ![[Untitled 30.png]]
    

==  
Теперь все  
====HTTP== ==сообщения делятся на фреймы== ==(HEADERS, DATA, RST_STREAM, PUSH_PROMISE, PRIORITY,etc)==

![[Untitled 31.png]]

==Коллекция таких фреймов== - ==двунаправленные поток== (`Stream`). Следовательно, ==каждый фрейм содержит идентификатор== ==(id)== ==потока  
Каждый  
====клиентский== ==запрос использует== ==нечетные== ==id====, а ответ от== ==сервера== ==-== ==четные====.==

![[Untitled 32.png]]

- ==Мультиплексирование== (==несколько асинхронных запросов через одно TCP- соединение== )  
    Благодаря  
    ==бинарному протоколу и представлению данных в виде фреймов и потоков, клиент и сервер могут обмениваться сообщениями асинхронно, используя лишь одно TCP соединение.==  
    Это также  
    ==решило проблему блокировки очереди запросов, когда медленный или большой запрос блокировал все последующие.==
- ==Server Push== (несколько ответов на один запрос)
    
    Сервер, зная, что клиент собирается запросить определенный ресурс,может отправить его сам, не дожидаясь запроса  
    Для этого сервер отправляет специальный фрейм PUSH_PROMISE с таким же id, что и запрос клиента  
    
    ![[Untitled 33.png]]
    
    ![[Untitled 34.png]]
    
- ==Сжатие заголовков методом HPACK==  
    Формат сжатия HTTP/2 заголовков HPACK состоит из трез основныз частей:  
    - Статическая таблица - общая для всех TCP соединений и содержит 61 часто используемые заголовки, которые можно найти в документации протокола
    - Динамическая таблица - создается для каждого TCP соединения и содержит используемые заголовки во время обмена сообщениями (ограниченного размера)
        
        ![[Untitled 35.png]]
        
        ![[Untitled 36.png]]
        
    - Сжатие заголовков алгоритмом Хаффмана
- ==Приоритизация запросов==  
    Клиент может назначить приоритет потоку (stream), добавив соответствующую информацию во фрейме HEADERS (число от 1 до 256), либо обновить уже созданный поток с помощью фрейма PRIORITY  
    Также каждому потоку может быть дана явная зависимость от другого потока, что вместе с приоритетами (пункт 1) представляет собой “дерево приоритетов”  
    
    ![[Untitled 37.png]]
    
- ==Безопасность==  
    Большинство клиентов (браузеров) поддерживают HTTP/2 только если он используется поверх протокола TLS ( т.е. должен использоваться протокол HTTPS)  
    В своб очередь, спецификация не требует данного ограничения  
    Сокращение числа подключений ввиду перечисленныз преимуществ HTTP/2 приводит к сокращению затратных “рукопожатий TLS” (TLS handshake)  
    

### Mime types

![[Untitled 38.png]]

Content type определяет каким типом данных является body. accept означает какой тип данных ожидает получить клиент.

  

MIME тип (MIME - Multipurpose Internet Mail Extensions) - это стандарт, используемый для идентификации типов данных в Интернете. Он предназначен для указания характеристик содержимого определенного файла или потока данных.

MIME типы обычно состоят из двух частей, разделенных косой чертой ("/") `type/subtype`. Первая часть определяет основную категорию типа данных, а вторая часть указывает на конкретный подтип или формат данных.

Например, "text/plain" - это MIME тип для обычного текстового файла, а "image/jpeg" - для изображений в формате JPEG. Другие примеры MIME типов включают "application/pdf" для документов в формате PDF, "audio/mp3" для аудиофайлов в формате MP3 и "video/mp4" для видеофайлов в формате MP4.

Также могут быть переданы параметры `type/subtype;parameter=value`

Подробнее [https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)

### Форматы данных







# Общие сведения о компьютерных сетях

## Лекция "Классификация сетей" (презентация).

![[Untitled 75.png]]

![[Untitled 76.png]]

![[Untitled 77.png]]

![[Untitled 78.png]]

![[Untitled 79.png]]

![[Untitled 80.png]]

## Лекция "Модель OSI"

![[Untitled 81.png]]

  

![[Untitled 82.png]]

![[Untitled 83.png]]

![[Untitled 84.png]]

![[Untitled 85.png]]

![[Untitled 86.png]]

![[Untitled 87.png]]

![[Untitled 88.png]]

- На практике сеансовый уровень не используется

![[Untitled 89.png]]

![[Untitled 90.png]]

![[Untitled 91.png]]

![[Untitled 92.png]]

  

## Лекция "Модель и стек протоколов TCP/IP"

![[Untitled 93.png]]

![[Untitled 94.png]]

![[Untitled 95.png]]

![[Untitled 96.png]]

  

  

### **Классический Ethernet (Shared Ethernet):**

- **Характеристики**: В классическом Ethernet используется среда передачи, общая для всех узлов сети. Это означает, что все устройства в сети могут слышать все передаваемые кадры.
- **Коллизии**: Поскольку все устройства используют общую среду передачи, могут возникать коллизии (столкновения) данных, когда несколько устройств пытаются передать данные одновременно.
- **Метод доступа**: В классическом Ethernet используется метод доступа CSMA/CD (Carrier Sense Multiple Access with Collision Detection), который позволяет устройствам контролировать доступ к среде передачи и обнаруживать коллизии.

### **Коммутированный Ethernet (Switched Ethernet):**

- **Характеристики**: В коммутированном Ethernet используются коммутаторы (switches), которые обеспечивают индивидуальное соединение между каждой парой устройств в сети. Каждое устройство имеет свое собственное соединение с коммутатором.
- **Отсутствие коллизий**: Поскольку каждое устройство имеет свое собственное соединение с коммутатором, коллизии данных практически исключены.
- **Метод доступа**: Коммутаторы используют коммутацию (switching), что означает, что они могут перенаправлять кадры только на те порты, на которые адресованы.

### **Основное отличие:**

Основное отличие между коммутированным и классическим Ethernet заключается в том, что в коммутированном Ethernet используется коммутатор для обеспечения индивидуального соединения между устройствами, в то время как в классическом Ethernet используется общая среда передачи, что может привести к коллизиям данных. Коммутированный Ethernet обеспечивает более высокую производительность и надежность сети, поскольку исключает коллизии и обеспечивает более эффективное использование пропускной способности.

# Модель OSI - именно про модель и общую концепцию всего

- `Прикладной уровень` Получает информацию, как есть в данных, которые ввел пользователь.

![[Untitled 97.png]]

- Заключается в том, чтобы данные `превратить в массив байт` (==Обязательно==)
- ==Шифрование/компрессия== (бысрее передавать по проводам) (необязательно)

![[Untitled 98.png]]

- `Session` - время открытие и закрытия соединение, когда общаются. (==Просто открывается соединение== и отправляются данные на уровень ниже)

![[Untitled 99.png]]

- ==В сети могут происходить сбои, пакеты могут быть битые и транспортный уровень занимается этим.==

![[Untitled 100.png]]

![[Untitled 101.png]]

- Разбиение сегмента на пакеты данных
- Доставка между разными сетями

![[Untitled 102.png]]

![[Untitled 103.png]]

![[Untitled 104.png]]

![[Untitled 105.png]]

![[Untitled 106.png]]

![[Untitled 107.png]]

![[Untitled 108.png]]

  

- `Канальный уровень` - проверяем целостность кадров.

![[Untitled 109.png]]

![[Untitled 110.png]]

![[Untitled 111.png]]

  

![[Untitled 112.png]]

  

# Сетевая маска

![[Untitled 113.png]]

![[Untitled 114.png]]

[localhost](http://localhost)

![[Untitled 115.png]]

![[Untitled 116.png]]

- ==Маска используется только для отправителя== (Потому что нужно определить подсеть, чтобы понять адрес сети)
- ==И когда у получается совпадает адрес сети, тогда маршрутизатор не отправит в другую сеть.==

![[Untitled 117.png]]

![[Untitled 118.png]]

![[Untitled 119.png]]

- `traceroate`

  

# DNS

![[Untitled 120.png]]

![[Untitled 121.png]]

![[Untitled 122.png]]

![[Untitled 123.png]]

![[Untitled 124.png]]

![[Untitled 125.png]]

- ==Происходит цепочка вызовов нужных доменов по уровням.==
- После ==получения доменого имени и IP адреса происходит уже запрос по IP==
- ==Кешируются== такие запросы локально и в днс серере (сразу вернут адрес ip)

==**Как это выглядит**==

![[Untitled 126.png]]

==Сначала в приоритете проверяется локальный файл== ==`hosts`====, если там не находится информация, которая нужна,то запрос идет по рутовоу доменному имени, получает== ==`ip`== ==следующей зоны и тд.==

  

# TCP / UDP

![[Untitled 127.png]]

- `TCP` и `UDP` ==могут быть одновременно на одном порту, так как компьютер обрабатывает их по разному==

# HTTP

![[Untitled 128.png]]

![[Untitled 129.png]]

![[Untitled 130.png]]

![[Untitled 131.png]]

![[Untitled 132.png]]

![[Untitled 133.png]]

![[Untitled 134.png]]

![[Untitled 135.png]]

![[Untitled 136.png]]

![[Untitled 137.png]]

Да, ==**можно получать данные через POST и отправлять данные через GET,**== но это не рекомендуется в соответствии с общепринятыми стандартами и семантикой HTTP. Передача конфиденциальных данных через `URL` запроса `GET` ==является небезопасной практикой, так как данные могут быть видны в адресной строке браузера или сохранены в истории браузера==. Вместо этого рекомендуется использовать методы соответственно их предназначению: `GET` для получения данных, `POST` для отправки данных.

Строго говоря, согласно спецификации протокола HTTP, ==метод GET не предполагает наличие тела сообщения==. GET-запросы используются исключительно для запроса ресурсов и передачи данных через URL строки запроса (query string). Таким образом, технически GET-запрос не имеет тела сообщения.

==Тем не менее, некоторые клиенты и серверы могут позволять включать тело сообщения в GET-запросы.== ==Однако это считается нарушением стандартов и может привести к непредсказуемому поведению==. Например, некоторые серверы могут проигнорировать тело сообщения в GET-запросе, а другие могут вернуть ошибку.

Поэтому, хотя некоторые реализации могут позволять вставлять тело сообщения в GET-запросы, это не является хорошей практикой и может привести к несовместимости и непредсказуемому поведению вашего приложения. Вместо этого, для передачи данных между клиентом и сервером через HTTP следует использовать методы, предназначенные для этой цели, такие как POST или PUT.

![[Untitled 138.png]]

![[Untitled 139.png]]

# MIME type

![[Untitled 140.png]]

![[Untitled 141.png]]

  

# Минусы Rest

![[Untitled 142.png]]

![[Untitled 143.png]]

![[Untitled 144.png]]