## Общие сведения

![[images/Untitled 154.png|Untitled 154.png]]

### Типы тестирования

Допустим, ты тестируешь типичный интернет-магазин. Тогда направления тестирования можно разбить на такие типы: тестирование производительности, функциональное тестирование, интеграционное тестирование и модульное тестирование.

Если владелец сайта решит запустить серьезную рекламную компанию, то на сайт одновременно придет куча пользователей. Вполне может быть, что сайт не упадет, но некоторые его разделы могут работать медленно или вообще перестать работать.

Для того, чтобы этого не случилось, тебе нужно заранее выявить такие проблемы и предпринять шаги для их устранения. Это делается с помощью нагрузочного тестирования, или его еще называют тестированием производительности.

Так же ты можешь захотеть проверить, как работает API твоего бэкенда и протестировать каждую его функцию: регистрацию, логин, добавление в корзину, обработку платежей, записи в базу данных и т. д. Все должно работать согласно ТЗ. В этом случае нужно выполнить функциональное тестирование.

Твой интернет-магазин скорее всего интегрирован со сторонними сервисами: рассылка писем и СМС, платежные системы, онлайн-чаты поддержки, сбор обратной связи от пользователей, рекламные системы и т. д. Чтобы убедиться, что все это работает как задумано, тебе нужно провести интеграционное тестирование.

И, наконец, сложные продукты часто разбивают на независимые модули. Из таких модулей можно собрать финальный продукт, как из конструктора. Если ты занимаешься разработкой такого модуля или взаимодействием таких модулей, то тебе понадобиться провести модульное тестирование.

  

Жизненный цикл тестирования, которому стоит придерживаться:

![[images/Untitled 1 15.png|Untitled 1 15.png]]

## JUNIT5

[https://www.baeldung.com/junit](https://www.baeldung.com/junit)

### Maven

Добавляется в pom.xml

```XML
<!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-engine -->
    <dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter-engine</artifactId>
      <version>5.8.0-M1</version>
      <scope>test</scope>
    </dependency>
    <!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api -->
    <dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter-api</artifactId>
      <version>5.8.0-M1</version>
      <scope>test</scope>
    </dependency>
    <!-- https://mvnrepository.com/artifact/org.junit.platform/junit-platform-launcher -->
    <dependency>
      <groupId>org.junit.platform</groupId>
      <artifactId>junit-platform-launcher</artifactId>
      <version>1.8.0-M1</version>
      <scope>test</scope>
    </dependency>
    <!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-params -->
    <dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter-params</artifactId>
      <version>5.8.0-M1</version>
      <scope>test</scope>
    </dependency>

    <dependency>
      <groupId>org.assertj</groupId>
      <artifactId>assertj-core</artifactId>
      <version>3.24.2</version>
      <scope>test</scope>
    </dependency>
```

### Junit Platform Launcher

[https://mvnrepository.com/artifact/org.junit.platform/junit-platform-launcher/1.10.0-M1](https://mvnrepository.com/artifact/org.junit.platform/junit-platform-launcher/1.10.0-M1)

Idea пользуется этим Launcher под капотом, но он нам не доступен, чтобы можно было программно прогонять тесты без компиляции проекта( проходя жизненные цикла мавена) необходимо:

- добавить зависимость в pom.xml

```XML
<dependency>
      <groupId>org.junit.platform</groupId>
      <artifactId>junit-platform-launcher</artifactId>
      <version>1.8.0-M1</version>
      <scope>test</scope>
</dependency>
```

- создать через фабрику Launcher

```Java
import org.junit.platform.launcher.Launcher;
import org.junit.platform.launcher.core.LauncherFactory;
Launcher launcher = LauncherFactory.create();

```

### интерфейс Launcher

```Java
public interface Launcher {
    @API(
        status = Status.STABLE,
        since = "1.10"
    )
//слушатель, который регистрирует поиск тестов
    void registerLauncherDiscoveryListeners(LauncherDiscoveryListener... var1);
//слушатель, который регистрирует прохождение тестов
    void registerTestExecutionListeners(TestExecutionListener... var1);
//найти тесты
    TestPlan discover(LauncherDiscoveryRequest var1);
//выполняет тесты, потом все равно оборачивается в метод с тест планом
    void execute(LauncherDiscoveryRequest var1, TestExecutionListener... var2);

    @API(
        status = Status.STABLE,
        since = "1.4"
    )
// выполняет тесты по плану
    void execute(TestPlan var1, TestExecutionListener... var2);
}
```

- создать LauncherDiscoveryRequest через Builder. В этом коде добавлен selectors, который позволяет выбрать путь по которому находятся наши тесты, можно указатьп пакет, класс,директорию, файл и тд

```Java
LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder
                .request()
//              .selectors(DiscoverySelectors.selectClass(MainTest.class))
                .selectors(DiscoverySelectors.selectPackage("com.konovalov"))
                .build();
```

- выполнить request через метод execute лаунчера

```Java
launcher.execute(request);
```

ВАЖНО: вторым параметром в execute можно передать listener, который можно создать на этапе создания самого лаунчера или requesta, можно создать предустановленный или кастомный, в коде использован предуставовленный listener, который позволяет генерировать статистку по выполненным тестам

```Java
Launcher launcher = LauncherFactory.create();
//        launcher.registerLauncherDiscoveryListeners();
//        launcher.registerTestExecutionListeners();

        SummaryGeneratingListener listener = new SummaryGeneratingListener();
        LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder
                .request()
//                .selectors(DiscoverySelectors.selectClass(MainTest.class))
                .selectors(DiscoverySelectors.selectPackage("com.konovalov"))
                .build();

        launcher.execute(request,listener);
```

- После выполения тестов можно вызвать у данного listener информацию о тестах

```Java
try(PrintWriter printWriter = new PrintWriter(System.out)){
            listener.getSummary().printTo(printWriter);
        }
```

Результат выполнения:

```Java
package com.konovalov.service;

import org.junit.jupiter.api.Test;

public class MainTest {

    @Test
    public void checkMainRunning(){}
}


Test run finished after 94 ms
[         2 containers found      ]
[         0 containers skipped    ]
[         2 containers started    ]
[         0 containers aborted    ]
[         2 containers successful ]
[         0 containers failed     ]
[         1 tests found           ]
[         0 tests skipped         ]
[         1 tests started         ]
[         0 tests aborted         ]
[         1 tests successful      ]
[         0 tests failed          ]


Process finished with exit code 0
```

### Аннотации

### @Test

```Java
package ru.konovalov;

public class Calculator {
    public int multiply(int x, int y){
        return x*y;
    }
}
```

Обычно для тестирования класса берут то же имя и добавляют суффикс Test. Для каждого метода нужно добавить хотя бы один тестовый метод.

```Java
package ru.konovalov;

import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class CalculatorTest {

    @Test
    public void multiply(){
        Calculator calculator = new Calculator();
        int multiply = calculator.multiply(10, 2);
        assertEquals(20, multiply);
    }
}
```

### @BeforeEach и @AfterEach

Часто в тестировании методов приходится создать экземпляр тестируемого класса. Чтобы каждый раз в тестовом методе не писать создание объекта, можно использовать **@BeforeEach**. Тогда Junit будет вызывать этот метод перед каждым тестовым методом

```Java
package ru.konovalov;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class CalculatorTest {
    Calculator calculator;

    @BeforeEach
    public void  init(){
        calculator = new Calculator();
    }

    @Test
    public void multiply(){
        int multiply = calculator.multiply(10, 2);
        assertEquals(20, multiply);
    }
}
```

**@AfterEach** позволяет запустить метод, помеченный этой аннотацией, после каждого тестового метода.

```Java
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class DatabaseTest {

    private Connection connection;

    @BeforeEach
    void setUp() throws SQLException {
        // Установка соединения с базой данных перед каждым тестом
        connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/mydatabase", "username", "password");
        System.out.println("Connected to database");
    }

    @AfterEach
    void tearDown() throws SQLException {
        // Закрытие соединения с базой данных после каждого теста
        if (connection != null && !connection.isClosed()) {
            connection.close();
            System.out.println("Connection to database closed");
        }
    }

    @Test
    void test1() {
        // Ваш код теста 1
    }

    @Test
    void test2() {
        // Ваш код теста 2
    }
}
```

Если у тебя есть 2 тестовых метода test1(), test2(), то порядок вызова будет таким:

- BeforeEach - метод
- test1()
- AfterEach - метод
- BeforeEach - метод
- test2()
- AfterEach - метод

### @BeforeAll и @AfterAll

JUnit также позволяет добавить метод, который будет вызван один раз перед всеми тестовыми методами. Такой метод нужно пометить аннотацией **@BeforeAll**. Для нее так же существует парная аннотация **@AfterAll**. Метод, помеченный ею, JUnit вызовет после всех тестовых методов.

```Java
package ru.konovalov;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;
public class CalculatorTest {
    Calculator calculator;

    @BeforeAll
     void  init(){
        calculator = new Calculator();
    }
    @AfterAll
    void deInit(){
        calculator = null;
    }

    @Test
    public void multiply(){
        int multiply = calculator.multiply(10, 2);
        assertEquals(20, multiply);
    }
}
```

**ВАЖНО**: если в примере выше объявить переменную calculator static, то следующий код выбросит исключение:

```Java
org.junit.platform.commons.JUnitException:
@BeforeAll method 'void ru.konovalov.CalculatorTest.init()'
must be static unless the test class is annotated
with @TestInstance(Lifecycle.PER_CLASS).
```

```Java
package ru.konovalov;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;
public class CalculatorTest {

    static Calculator calculator;

    @BeforeAll
     void  init(){
        calculator = new Calculator();
    }
    @AfterAll
    void deInit(){
        calculator = null;
    }

    @Test
    public void multiply(){
        int multiply = calculator.multiply(10, 2);
        assertEquals(20, multiply);
    }
}
```

Решается это аннотацией @TestInstance(TestInstance.Lifecycle.PER_CLASS).

Либо использовать @TestInstance(TestInstance.Lifecycle.PER_METHOD), а методы, помечаемые @BeforeAll и @AfterAll необходимо сделать static

```Java
package ru.konovalov;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;

import static org.junit.jupiter.api.Assertions.assertEquals;
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
public class CalculatorTest {
    static Calculator calculator;

    @BeforeAll
     void  init(){
        calculator = new Calculator();
    }
    @AfterAll
    void deInit(){
        calculator = null;
    }

    @Test
    public void multiply(){
        int multiply = calculator.multiply(10, 2);
        assertEquals(20, multiply);
    }
}
```

### @Disabled

Аннотация позволяет выключить определенный тест, чтобы JUnit его не вызывал.

```Java
public class AppTest {

    @Disabled("Тест временно отключен")
    @Test
    void testOnDev(){
        System.setProperty("ENV", "DEV");
        Assumptions.assumeFalse("DEV".equals(System.getProperty("ENV")));
    }
}
```

Аннотацию `@Disabled` можно написать сразу перед объявлением класса, тогда все его методы будут проигнорированы.

```Java
@Disabled("Временно отключили тест, починим к маю 2001 года")
public class AppTest {
    @Test
    void testOnDev(){
        System.setProperty("ENV", "DEV");
        Assumptions.assumeFalse("DEV".equals(System.getProperty("ENV")));
    }

    @Test
    void testOnProd(){
     System.setProperty("ENV", "PROD");
        Assumptions.assumeFalse("DEV".equals(System.getProperty("ENV")));
    }
}
```

### @Tag

Используется для пометки тестовых методов определенным тегами. После этого можно запускать определенную группу или группы методов с одним и тем же тегом.

```Java
package com.konovalov.service;

import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;

public class MainTest {
    @Tag("excluded")
    @Test
    public void checkMainRunning(){}

    @Tag("login")
    @Test
    public void loginUser(){}
    @Tag("excluded")
    @Test
    public void deleteUser(){}

    @Tag("login")
    @Test
    public void loginWithoutPassword(){}
}
```

Запустить определенные группы можно следующим образом. ==**ВАЖНО:**== не забыть добавить в зависимость maven-surefire-plugin :

```Java
mvn clean test -Dgroups=login //запуск определенной группы
mvn clean test -Dgroups=login, someTags, ... //запуск  групп
mvn clean test -DexcludedGroups=excluded //пропустить группу тестов
```

через Launcher и методы filters(TagFilter. exclude or include ), описан в Junit Platform Launcher

```Java
public class TestLauncher {
    public static void main(String[] args) {
        Launcher launcher = LauncherFactory.create();
//        launcher.registerLauncherDiscoveryListeners();
//        launcher.registerTestExecutionListeners();

        SummaryGeneratingListener listener = new SummaryGeneratingListener();
        LauncherDiscoveryRequest request = LauncherDiscoveryRequestBuilder
                .request()
                .selectors(DiscoverySelectors.selectClass(com.konovalov.service.MainTest.class))
                .selectors(DiscoverySelectors.selectPackage("com.konovalov.service"))
                .filters(TagFilter.includeTags("login"))
                .filters(TagFilter.excludeTags("excluded"))
                .build();

        launcher.execute(request,listener);

        try(PrintWriter printWriter = new PrintWriter(System.out)){
            listener.getSummary().printTo(printWriter);
        }
    }
}
```

### @Nested

Чтобы вызвать методы вложенного класса перед его объявлением, нужно написать аннотацию `@Nested`.

```Java
public class AppTest {
    @Nested
    public class DevStagingEnvironment {
    @Test
        void testOnDev(){
            System.setProperty("ENV", "DEV");
            Assumptions.assumeFalse("DEV".equals(System.getProperty("ENV")));
        }
   }

    @Nested
    public class ProductionEnvironment {
        @Test
        void testOnProd(){
           System.setProperty("ENV", "PROD");
           Assumptions.assumeFalse("DEV".equals(System.getProperty("ENV")));
        }
   }
}
```

### @ExtendWith

Аннотация `@ExtendWith` в JUnit 5 используется для расширения функциональности тестового фреймворка. Она позволяет вам добавить дополнительные возможности или изменить поведение тестового выполнения путем подключения различных расширений (extensions).

В JUnit 5 расширения представляют собой компоненты, которые могут модифицировать выполнение тестов или предоставлять дополнительные функции. Расширения могут влиять на каждый тестовый метод или на весь тестовый класс.

Вот пример использования аннотации `@ExtendWith` с расширением MockitoExtension:

```Java
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class ExampleTest {

    @Mock
    private SomeDependency dependency;

    @Test
    void testSomething() {
        // Некоторый код теста, использующий зависимость "dependency"
        when(dependency.someMethod()).thenReturn("mocked result");
        // ...
    }
}
```

В этом примере класс `ExampleTest` аннотирован `@ExtendWith(MockitoExtension.class)`, чтобы использовать расширение MockitoExtension. Расширение MockitoExtension интегрирует фреймворк Mockito в тестовый процесс и позволяет использовать аннотации Mockito, такие как `@Mock` и `@InjectMocks`, для создания и внедрения моков и заглушек.

Аннотация `@ExtendWith` может использоваться с одним или несколькими расширениями. Вы также можете создавать собственные расширения, реализуя интерфейс `org.junit.jupiter.api.extension.Extension`.

Обратите внимание, что использование аннотации `@ExtendWith` требует наличия соответствующей зависимости в вашем проекте, чтобы подключить нужное расширение. Например, для использования MockitoExtension вам понадобится зависимость на Mockito в вашем проекте.

### @Timeout

Позволяет задать время на выполнение теста. Если выполнение теста заняло больше времени, чем указанно в аннотации, то он считается проваленным. Самое полезное, что можно поставить TimeOut на весь класс, содержащий методы!

```Java
class TimeoutDemo {
    @Test
    @Timeout(value = 100, unit = TimeUnit.MILLISECONDS)
    void failsIfExecutionTimeExceeds100Milliseconds() {
        // тест упадет, если займет более 100 миллисекунд
    }
}
```

Аналогично можно использовать assertions:

```Java
@RepeatedTest(value = 5,name = RepeatedTest.LONG_DISPLAY_NAME)
    void testWithMethodSource(){
      assertTimeoutPreemptively(Duration.ofMillis(200L), ()-> {
          userService.login("vadim", "1213123");
              });
    }

@RepeatedTest(value = 5,name = RepeatedTest.LONG_DISPLAY_NAME)
    void testWithMethodSource(){
      assertTimeoutPreemptively(Duration.ofMillis(200L), ()-> {
          Thread.sleep(3000);
          userService.login("vadim", "1213123");
          //org.opentest4j.AssertionFailedError: execution timed out after 200 ms
              });
    }
```

### @ParameterizedTest

Аннотация необходима, чтобы вызвать тест с несколькими параметрами. Для начала необходимо добавить зависимость в pom.

```XML
<dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter-params</artifactId>
      <version>5.9.2</version>
      <scope>test</scope>
    </dependency>
```

Каждый тестовый метод вызовется по 3 раза и при каждом вызове в него будет передан очередной параметр. Значения задаются с помощью другой аннотации — ==@ValueSource==.

```Java
@ParameterizedTest
    @ValueSource(ints = { 1, 2, 3 })
    public void multiply(int argument){
        int multiply = calculator.multiply(10, argument);
        assertEquals(10 * argument, multiply);
    }
```

Можно использовать стрим, используя дженерик Argumnts из библиотеике JUNIT, чтобы запустить сразу несколько тестов:

```Java
public class UserService {

    public boolean login(String user, String password){
        HashMap<String, String> map = new HashMap<>();
        map.put("Ivan", "123");
        map.put("Petr", "123213");
        map.put("Sasha", "ssss");


        return map.containsKey(user) && map.get(user).equals(password);
    }
```

```Java
@ParameterizedTest
    @MethodSource("getStreamForLoginTest")
    void testWithMethodSource(String name, String password){
        boolean login = userService.login(name, password);
        assertThat(login).isTrue(); //все тесты пройдут (3 штуки)
    }



    public Stream<Arguments> getStreamForLoginTest(){
        return Stream.of(
                Arguments.of("Ivan", "123"),
                Arguments.of("Petr", "123213"),
                Arguments.of("Sasha", "ssss")
        );
    }
```

  

### @ValueSource и @NullSource @EmptySource

Аннотация @ValueSource отлично подходит для работы с примитивами и литералами. Просто перечисли значения параметра через запятую и тест будет вызван по одному разу для каждого значения.

```Java
@ParameterizedTest
@ValueSource(ints = { 1, 2, 3 })
void testMethodWithAutoboxing(Integer argument) {
    //test code
}
```

Но есть и минус — эта аннотация не поддерживает null, так что для него нужно будет использовать специальный костыль — @NullSource. Выглядит это так:

```Java
@ParameterizedTest
@NullSource
void testMethodNullSource(Integer argument) {
    assertTrue(argument == null);
}
```

@EmptySource передает пустую строку в качестве аргумента

```Java
@ParameterizedTest
    @EmptySource
    void testEmpty(String emptyLine){
        assertThat(emptyLine).isEqualTo("");
    }
```

Можно использовать сразу несколько аннотаций:

```Java
@ParameterizedTest
    @EmptySource
    @ValueSource(strings = {"242432", "dsfsfsdf", "124395"})
    void loginUser(String password){

        boolean actual = userService.login(password);
        assertThat(actual).isTrue();
    }
}

```

### @EnumSource

Аннотация которая передает в метод все значения определенного Enum’а. Ее применение выглядит так:

```Java
enum Direction {
    EAST, WEST, NORTH, SOUTH
}

@ParameterizedTest
@EnumSource(Direction.class)
void testWithEnumSource(Direction d) {
    assertNotNull(d);
}
```

### @MethodSource

Чтобы передавать в качестве параметров объекты, которые имеют сложный алгоритм построения, можно просто создать специальный вспомогательный метод, который будет возвращать список (Stream) из  
таких значений. А дальше этот метод передавать в тестовый метод через аннотацию.  

```Java
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;

import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class CalculatorTest {

    private Calculator calculator = new Calculator();

    @ParameterizedTest
    @MethodSource("multiplyArguments")
    public void multiply(int argument) {
        int multiply = calculator.multiply(10, argument);
        assertEquals(10 * argument, multiply);
    }

    private static Stream<Integer> multiplyArguments() {
        return Stream.of(1, 2, 3);
    }
}
```

Можно указать любой статический метод в любом пакете следующим образом

```Java
package com.konovalov;

public List<Integer> getArgumentsForTest(){
        ArrayList<String> list = new ArrayList<>();
        list.add("value");
        list.add("value");
        list.add("something");
        return new ArrayList<>();

    }


@MethodSource("com.konovalov.UserService\#getArgumentsForTest")
    void testWithMethodSource(List<Integer> list){
        int n = 0;
        Predicate<String> predicate = s-> s.equals("value");
        Condition condition = new Condition<>(predicate,"actual is equals to value");
        assertThat(list).areAtLeast(n, condition);
    }


ВАЖНО СОЗДАТЬ Resolver!!!

public class UserServiceParamResolver implements ParameterResolver {
    @Override
    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {
        return parameterContext.getParameter().getType() == UserService.class;
    }

    @Override
    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {
        ExtensionContext.Store store = extensionContext.getStore(ExtensionContext.Namespace.create(UserService.class));
        return store.getOrComputeIfAbsent(UserService.class, it -> new UserService());
    }
}
```

### @CSVSource

Аннотация позволяет перечислить значения параметров метода просто через запятую.

```Java
@ParameterizedTest
@CsvSource({
    "alex, 30, Программист, Работает",
    "brian, 35, Тестировщик, Работает",
	"charles, 40, Менеджер, Пинает"
})
void testWithCsvSource(String name, int age, String occupation, String status) {
	//код метода
}
```

### @CSVFileSource

можно поместить в resources файл с расширением csv и передавать аргументы в тестовый метод оттуда

```XML
 test.csv
USERNAME, PASSWORD
Ivan,123
Petr,123213
Sasha,ssss
```

```Java

    @ParameterizedTest
    @CsvFileSource(resources = "/test.csv", delimiter = ',',numLinesToSkip = 1)
    void testWithMethodSource(String name, String password){
        boolean login = userService.login(name, password);
        assertThat(login).isTrue();
    }
```

### @TestMethodOrder

`@TestMethodOrder`. Она позволяет задать порядок вызова тестовых методов в тестовом классе. Бывает очень полезна, когда вы знаете, что вызовы методов влияют друг на друга, но при определенном  
порядке все должно работать, как нужно. Используется довольно часто.  

![[images/Untitled 2 14.png|Untitled 2 14.png]]

### OrderAnnotation

Запускает методы в том порядке, в котором помечены тестовые методы аннотацией @Order(число)

@Order это антипаттерн. Если тесты зависят друг от друга или от условий, это плохие тесты

```Java
package ru.konovalov;

import org.junit.jupiter.api.*;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

import static org.junit.jupiter.api.Assertions.assertEquals;
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class CalculatorTest {
    static Calculator calculator;

    @BeforeAll
     void  init(){
        calculator = new Calculator();
    }
    @AfterAll
    void deInit(){
        calculator = null;
    }
    @Order(2)
    @ParameterizedTest
    @ValueSource(ints = { 1, 2, 3 })
    public void multiply(int argument){
        int multiply = calculator.multiply(10, argument);
        assertEquals(10 * argument, multiply);
    }

    @Order(1)
    @ParameterizedTest
    @ValueSource(ints = { 5, 10, 20 })
    public void div(int argument){
        double div = calculator.division(100, argument);
        assertEquals((double) 100 / argument, div);
    }
}
```

### Random

Запускает тесты в рандомном порядке, даже если выставлены аннотации @Order

![[images/Untitled 3 13.png|Untitled 3 13.png]]

![[images/Untitled 4 13.png|Untitled 4 13.png]]

  

### MethodName

Запускает тесты в алфавитном порядке названий методов

```Java
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
@TestMethodOrder(MethodOrderer.MethodName.class)
public class CalculatorTest {

    @Test
    @DisplayName("Проверка входных данных")
    void inputData() {}

    @DisplayName("Проверка критических ситуаций")
    @Test
    void criticalCases() {}
    @Test
    @DisplayName("Билдинг конфиг файлов")
    void buildConfig() {}
}
```

![[images/Untitled 5 13.png|Untitled 5 13.png]]

### @DisplayName

Каждому тесту можно задавать его имя. Бывает удобно, если тестов очень  
много и вы создаете специальные сценарии (подмножества) тестов. Для  
этого есть специальная аннотация  
`@DisplayName`.

```Java
@DisplayName("Понятное имя для теста")
public class DisplayNameCustomTest {

    @Test
    @DisplayName("Проверка входных данных")
    void inputData() {
    }

    @DisplayName("Проверка критических ситуаций")
    @Test
    void criticalCases() {
    }
}
```

![[images/Untitled 6 12.png|Untitled 6 12.png]]

Также можно присваивать названия вложенным группам:

```Java
package ru.konovalov;

import org.junit.jupiter.api.*;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

import java.util.Arrays;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

@TestInstance(TestInstance.Lifecycle.PER_CLASS)
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class CalculatorTest {

    @Test
    @DisplayName("Проверка входных данных")
    void inputData() {
    }

    @DisplayName("Проверка критических ситуаций")
    @Test
    void criticalCases() {
    }
    @DisplayName("util testing")
    @Nested
    class UtilsTest {
        @DisplayName("тестирование утилиты такой-то ...")
        @Test
        void testUtil(){
        }
    }
}
```

![[images/Untitled 7 11.png|Untitled 7 11.png]]

### @RepeatedTest

Аннотация позволяет запустить несколько раз один и тот же тест, полезно при нахождении flaky tests( которые не всегда отрабатывают правильно)

```Java
@RepeatedTest(value = 5,name = RepeatedTest.LONG_DISPLAY_NAME)
    void testWithMethodSource(){
        boolean login = true;
        assertThat(login).isTrue();
    }
```

![[images/Untitled 8 11.png|Untitled 8 11.png]]

### Assertions

[https://junit.org/junit5/docs/5.0.1/api/org/junit/jupiter/api/Assertions.html](https://junit.org/junit5/docs/5.0.1/api/org/junit/jupiter/api/Assertions.html)

==**ВАЖНО**==: через лямбда выражение можно передать сообщение, которое высветится в случае проваленного теста:

```Java
@Test
    @DisplayName("Билдинг конфиг файлов")
    void buildConfig() {
        assertFalse(true, ()->"Must be false");
    }
```

```Java
org.opentest4j.AssertionFailedError: Must be false ==> 
Expected :false
Actual   :true
<Click to see difference>
```

- `assertAll()` Этот метод используется для выполнения нескольких утверждений одновременно. Если одно из утверждений не пройдет, будет сгенерировано исключение.

```Java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class ExampleTest {
    @Test
    void testAssertAll() {
        String name = "John";
        int age = 25;
        
        assertAll("person",
            () -> assertEquals("John", name),
            () -> assertTrue(age > 18)
        );
    }
}
```

- `assertArrayEquals()` Этот метод используется для проверки равенства двух массивов. Он сравнивает каждый элемент массива на соответствие.

```Java
@Test
    public void whenAssertingArraysEquality() {
        char[] expected = {'J','u','n','i','t'};
        char[] actual = "Junit".toCharArray();

        assertArrayEquals(expected, actual); //true
    }
```

- `assertEquals()` Этот метод используется для проверки равенства двух значений или объектов. Он сравнивает значения с помощью оператора `equals()` или оператора `==`, в зависимости от типа данных.

```Java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class ExampleTest {
    @Test
    void testAssertEquals() {
        String expected = "Hello";
        String actual = "Hello";
        
        assertEquals(expected, actual); /true
    }
}
```

- `assertFalse()` Этот метод используется для проверки, что условие ложно. Если условие истинно, будет сгенерировано исключение.

```Java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class ExampleTest {
    @Test
    void testAssertFalse() {
        boolean value = true;
        
        assertFalse(value); // тест будет провален
    }
}
```

- `assertIterableEquals()` Этот метод используется для проверки равенства двух итерируемых объектов, таких как списки или наборы. Он сравнивает элементы итерируемых объектов на соответствие.

```Java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

import java.util.Arrays;
import java.util.List;

public class ExampleTest {
    @Test
    void testAssertIterableEquals() {
        List<String> expected = Arrays.asList("apple", "banana", "cherry");
        List<String> actual = Arrays.asList("apple", "banana", "cherry");
        
        assertIterableEquals(expected, actual); //тест пройден
    }

@Test
    void testAssertIterableEquals2() {
        List<String> expected = Arrays.asList("apple", "banana", "cherry");
        List<String> actual = Arrays.asList("banana", "apple", "cherry");

        assertIterableEquals(expected, actual); // этот провален
    }
}
```

- `assertLinesMatch()` Этот метод используется для проверки соответствия ожидаемого списка строк с фактическим списком строк. Он особенно полезен для сравнения вывода, содержащего переносы строк.

```Java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

import java.util.Arrays;
import java.util.List;

public class ExampleTest {
    @Test
    void testAssertLinesMatch() {
        List<String> expected = Arrays.asList("Hello", "World");
        List<String> actual = Arrays.asList("Hello", "World");
        
        assertLinesMatch(expected, actual); // тест пройден
    }
}
```

- `assertNotEquals()`Этот метод используется для проверки, что два значения или объекта не равны. Если значения равны, будет сгенерировано исключение.

```Java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class ExampleTest {
    @Test
    void testAssertNotEquals() {
        int expected = 5;
        int actual = 10;
        
        assertNotEquals(expected, actual); // тест пройден
    }
}
```

- `assertNotNull()` Этот метод используется для проверки, что значение или объект не равны `null`. Если значение равно `null`, будет сгенерировано исключение.

```Java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class ExampleTest {
    @Test
    void testAssertNotNull() {
        String value = "Hello";
        
        assertNotNull(value); //тест пройден
    }
}
```

- `assertNotSame()` Этот метод используется для проверки, что два объекта не являются ссылками на один и тот же объект. Если объекты являются ссылками на один и тот же объект, будет сгенерировано исключение.

```Java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class ExampleTest {
    @Test
    void testAssertNotSame() {
        String expected = "Hello";
        String actual = new String("Hello");
        
        assertNotSame(expected, actual);
    }
}
```

- `assertNull()` Этот метод используется для проверки, что значение или объект равны `null`. Если значение не равно `null`, будет сгенерировано исключение.

```Java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class ExampleTest {
    @Test
    void testAssertNull() {
        String value = null;
        
        assertNull(value);
    }
}
```

- `assertSame()` Этот метод используется для проверки, что два объекта являются ссылками на один и тот же объект. Если объекты не являются ссылками на один и тот же объект, будет сгенерировано исключение.

```Java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class ExampleTest {
    @Test
    void testAssertSame() {
        String expected = "Hello";
        String actual = expected;
        
        assertSame(expected, actual);
    }
}
```

- `assertThrows()` Этот метод используется для проверки, что выполнение определенной операции вызывает исключение определенного типа. Если исключение не было вызвано или тип исключения не совпадает, будет сгенерировано исключение.

```Java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class ExampleTest {
    @Test
    void testAssertThrows() {
        assertThrows(ArithmeticException.class, () -> {
            int result = 1 / 0;
        }); тест пройден так как выбросится исключение
    }
}


@Test
void throwException(){
assertThrows(IllegalArgumentException.class, ()-> userService.login(null, "dummy"));
}

@Test
void throws2Exception(){
assertAll(
()-> assertThrows(IllegalArgumentException.class, ()-> userService.login(null, "dummy"));
()->assertThrows(IllegalArgumentException.class, ()-> userService.login("dummy",null ));
);
}
```

- `assertTimeout()` Этот метод используется для проверки, что определенный блок кода выполняется в течение указанного времени. Если блок кода занимает больше времени, чем указанное, будет сгенерировано исключение.

```Java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class ExampleTest {
    @Test
    void testAssertTimeout() {
        assertTimeout(Duration.ofSeconds(1), () -> {
            Thread.sleep(500);
        });
    }
}
```

- `assertTimeoutPreemptively()` Этот метод используется для проверки, что определенный блок кода выполняется в течение указанного времени. Он работает аналогично `assertTimeout()`, но использует альтернативный механизм для прерывания выполнения блока кода.

```Java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class ExampleTest {
    @Test
    void testAssertTimeoutPreemptively() {
        assertTimeoutPreemptively(Duration.ofSeconds(1), () -> {
            Thread.sleep(500);
        });
    }
}
```

- `assertTrue()` Этот метод используется для проверки, что условие истинно. Если условие ложно, будет сгенерировано исключение.

```Java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class ExampleTest {
    @Test
    void testAssertTrue() {
        boolean value = true;
        
        assertTrue(value);
    }
}
```

- `fail()` Этот метод используется для явного генерирования исключения, чтобы указать неудачу теста. Его можно использовать, когда тест не может быть выполнен или для обозначения неполной реализации теста.

```Java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class ExampleTest {
    @Test
    void testFail() {
        fail("This test is meant to fail");
    }
}
```

### Extension model

![[images/Untitled 9 11.png|Untitled 9 11.png]]

![[images/Untitled 10 9.png|Untitled 10 9.png]]

### Test life cycle callbacks

![[images/Untitled 11 9.png|Untitled 11 9.png]]

Реализуем класс которые имплементирует следующие CallBack, переопределяем методы

```Java
package com.konovalov.service;

import org.junit.jupiter.api.extension.*;

public class GlobalExtentsion implements AfterTestExecutionCallback, BeforeTestExecutionCallback, BeforeAllCallback, AfterAllCallback,BeforeEachCallback, AfterEachCallback {
    @Override
    public void afterTestExecution(ExtensionContext context) throws Exception {
        System.out.println(context.getTestMethod()+"выполнился");
    }   
    @Override
    public void beforeAll(ExtensionContext context) throws Exception {
        System.out.println("Это перед всеми тестами");
    }
    @Override
    public void beforeEach(ExtensionContext context) throws Exception {
        System.out.println("Это перед каждым тестом");
    }

    @Override
    public void beforeTestExecution(ExtensionContext context) throws Exception {
        System.out.println(context.getTestMethod()+"сейчас начнет выполнение");
    }
    @Override
    public void afterEach(ExtensionContext context) throws Exception {
        System.out.println("Это выведется после каждого теста ");
    }
    @Override
    public void afterAll(ExtensionContext context) throws Exception {
        System.out.println("Это выведется после всех тестов");
    }


 

  
}
```

В тестовом классе необходимо указать, что запускается с @ExtendWith({GlobalExtentsion.class})

```Java
@ExtendWith({GlobalExtentsion.class})
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
public class MainTest {
```

  

### Test-instance post-processing

Этот код представляет собой реализацию интерфейса `TestInstancePostProcessor` из библиотеки JUnit 5, который позволяет выполнять дополнительную обработку экземпляра тестового класса после его создания.

Конкретно, данный код определяет класс `PostProcessTestInstance`, который является пост-процессором для экземпляра тестового класса. В методе `postProcessTestInstance` класса `PostProcessTestInstance` выполняется обработка экземпляра тестового класса после его создания.

В данном случае, код получает список объявленных полей (`declaredFields`) для экземпляра `testInstance` и проходится по каждому полю. Если поле имеетаннотацию `Getter.class` , то устанавливается новый экземпляр класса `UserService` в это поле с помощью метода `declaredField.set()`.

Таким образом, данный код предоставляет возможность выполнять дополнительную обработку экземпляра тестового класса после его создания. В данном случае, если поле имеет аннотацию `Getter.class`, то оно будет инициализировано новым экземпляром класса `UserService`.

```Java
package com.konovalov.service;

import com.konovalov.UserService;
import org.junit.jupiter.api.TestInstance;
import org.junit.jupiter.api.extension.ExtensionContext;
import org.junit.jupiter.api.extension.TestInstancePostProcessor;

import java.lang.reflect.Field;

public class PostProcessTestInstance implements TestInstancePostProcessor {
    @Override
    public void postProcessTestInstance(Object testInstance, ExtensionContext context) throws Exception {
        System.out.println();
        var declaredFields = testInstance.getClass().getDeclaredFields();
        for (Field declaredField : declaredFields) {
            if(declaredField.isAnnotationPresent(Getter.clas)){
                declaredField.set(testInstance,new UserService());
            }
        }
    }
}
```

  

### Conditional test extension

Этот код представляет собой реализацию интерфейса `ExecutionCondition` из библиотеки JUnit 5, которая позволяет условно выполнять или пропускать тесты в зависимости от наличия системного свойства.

```Java
package com.konovalov.service;

import org.junit.jupiter.api.extension.ConditionEvaluationResult;
import org.junit.jupiter.api.extension.ExecutionCondition;
import org.junit.jupiter.api.extension.ExtensionContext;

import java.util.Properties;

public class ConditionalExtension implements ExecutionCondition {
    @Override
    public ConditionEvaluationResult evaluateExecutionCondition(ExtensionContext context) {
        Properties properties = System.getProperties();
        ConditionEvaluationResult testIsSkipped;
        if (properties.containsKey("skip")){
            testIsSkipped= ConditionEvaluationResult.disabled("test is skipped");
        }
        else testIsSkipped = ConditionEvaluationResult.enabled("test будет выполнен");
        return  testIsSkipped;
    }

}
```

Необходимо добавить в @ExtendWIth

```Java
package com.konovalov.service;

import com.konovalov.UserService;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

import java.time.Duration;

import static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively;

@ExtendWith({UserServiceParamResolver.class, ConditionalExtension.class})
public class MainTest {

    private static UserService userService;

    @BeforeAll
    static void  prepare(UserService userService){
        MainTest.userService = userService;
    }

    @Test
    void testWithMethodSource(){
      assertTimeoutPreemptively(Duration.ofMillis(200L), ()-> {
          userService.login("vadim", "1213123");
          //org.opentest4j.AssertionFailedError: execution timed out after 200 ms
              });
    }

}
```

В итоге тест пропускается( целиком класс)

![[images/Untitled 12 9.png|Untitled 12 9.png]]

![[images/Untitled 13 9.png|Untitled 13 9.png]]

### Parameter resolution

Пример тестов с зависимостью от UserService

```Java
package com.konovalov.service;

import com.konovalov.UserService;
import org.assertj.core.api.Condition;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.params.provider.MethodSource;

import java.util.ArrayList;
import java.util.function.Predicate;

import static org.assertj.core.api.Assertions.assertThat;
@ExtendWith({UserServiceParamResolver.class, ArrayListResolver.class})
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
public class MainTest {

    private UserService userService;
    @BeforeAll
    void prepare(UserService userService){
        this.userService = userService;
    }

    @Test
    @MethodSource()
    void testLogin(){
        boolean result =  userService.login("124395");
        assertThat(result).isTrue();
    }

    @Test
    @MethodSource("com.konovalov.UserService\#getArgumentsForTest")
    void testWithMethodSource(ArrayList<String> list){
        int n = 2;
        Predicate<String> predicate = s-> s.equals("value");
        Condition condition = new Condition<>(predicate,"actual is equals to value");
        assertThat(list).areAtLeast(n, condition);
    }
}
```

```Java
package com.konovalov;

import java.util.ArrayList;

public class UserService {

    public boolean login(String password){
        return password.equals("124395");
    }

    public ArrayList<String> getArgumentsForTest(){
        ArrayList<String> list = new ArrayList<>();
        list.add("value");
        list.add("value");
        list.add("something");
        return list;

    }
}
```

Чтобы внедрить зависимости необходимо создать Resolvers

Этот код представляет собой реализацию интерфейса `ParameterResolver` из библиотеки JUnit 5, который позволяет автоматически разрешать зависимости параметров тестовых методов.

Конкретно, данный код определяет класс `UserServiceParamResolver`, который является параметрическим resolver'ом для типа `UserService`. Класс `UserService` представляет сервисную функциональность для работы с пользователями.

Метод `supportsParameter` определяет, поддерживает ли данный Resolver параметр с заданным контекстом. В данном случае, если тип параметра совпадает с типом `UserService`, то метод возвращает `true`, что означает, что данный resolver может разрешить этот параметр.

Метод `resolveParameter` разрешает параметр тестового метода. В данном случае, он получает или создает экземпляр класса `UserService` и возвращает его. Он использует `ExtensionContext.Store`, чтобы сохранить экземпляр сервиса в хранилище `ExtensionContext` для повторного использования при разрешении параметров в других тестовых методах.

Таким образом, данный код предоставляет механизм автоматического разрешения зависимости типа `UserService` в тестовых методах, позволяя использовать экземпляр `UserService` без явного создания или передачи его в качестве параметра

```Java
package com.konovalov.service;

import com.konovalov.UserService;
import org.junit.jupiter.api.extension.ExtensionContext;
import org.junit.jupiter.api.extension.ParameterContext;
import org.junit.jupiter.api.extension.ParameterResolutionException;
import org.junit.jupiter.api.extension.ParameterResolver;

public class UserServiceParamResolver implements ParameterResolver {
    @Override
    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {
        return parameterContext.getParameter().getType() == UserService.class;
    }

    @Override
    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) throws ParameterResolutionException {
        ExtensionContext.Store store = extensionContext.getStore(ExtensionContext.Namespace.create(UserService.class));
        return store.getOrComputeIfAbsent(UserService.class, it -> new UserService());
    }
}
```

```Java
package com.konovalov.service;

import org.junit.jupiter.api.extension.ExtensionContext;
import org.junit.jupiter.api.extension.ParameterContext;
import org.junit.jupiter.api.extension.ParameterResolver;

import java.lang.reflect.Parameter;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

public class ArrayListResolver implements ParameterResolver {
    @Override
    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
        // Проверяем, подходит ли тип параметра
        Parameter parameter = parameterContext.getParameter();
        return parameter.getParameterizedType().getTypeName().equals("java.util.ArrayList<java.lang.String>");
    }

    @Override
    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
        // Создаем и возвращаем список значений для параметра
        List<String> values = new ArrayList<>();
        // Добавьте здесь свою логику для получения значений списка
        // В данном примере просто добавляем некоторые тестовые значения
        values.add("value");
        values.add("value");
        values.add("something");
        return values;
    }
}
```

### Exception handling

  

```Java
package com.konovalov.service;

import org.junit.jupiter.api.extension.ExtensionContext;
import org.junit.jupiter.api.extension.TestExecutionExceptionHandler;

public class ThrowableExtension implements TestExecutionExceptionHandler {
    @Override
    public void handleTestExecutionException(ExtensionContext context, Throwable throwable) throws Throwable {
        if(throwable instanceof IllegalArgumentException){
            throw throwable;
        }
    }
}
```

Этот код представляет собой реализацию интерфейса `TestExecutionExceptionHandler` из библиотеки JUnit 5, который позволяет обрабатывать исключения, возникающие во время выполнения тестового метода.

Конкретно, данный код определяет класс `ThrowableExtension`, который является расширением (extension) для обработки исключений в тестовых методах. В методе `handleTestExecutionException` класса `ThrowableExtension` происходит обработка исключения, которое возникает во время выполнения тестового метода.

В данном случае, код проверяет, является ли `throwable` (перехваченное исключение) экземпляром класса `IllegalArgumentException`. Если это так, то исключение просто пробрасывается дальше. В противном случае, исключение игнорируется и тестовый метод продолжает выполнение.

Таким образом, данный код предоставляет возможность управлять обработкой исключений в тестовых методах. В данном случае, если возникает исключение типа `IllegalArgumentException`, то оно будет проброшено дальше, а если возникает другое исключение, то оно будет проигнорировано и выполнение тестового метода будет продолжено.

```Java
package com.konovalov.service;

import com.konovalov.UserService;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

import java.io.IOException;
import java.time.Duration;

import static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively;

@ExtendWith({UserServiceParamResolver.class, ThrowableExtension.class})
public class MainTest {

    private static UserService userService;

    @BeforeAll
    static void  prepare(UserService userService){
        MainTest.userService = userService;
    }

    @Test
    void testWithMethodSource() throws IOException {
        if(true){
            throw new IOException();
        }
      assertTimeoutPreemptively(Duration.ofMillis(200L), ()-> {
          userService.login("vadim", "1213123");
//org.opentest4j.AssertionFailedError: execution timed out after 200 ms
              });
    }

}

ЭТОТ ТЕСТ ВЫПОЛНИТСЯ, несмотря на пробрасывание исключения(игнорируется
хандлером
```

## Mockito

В процессе развития и становления тестирования очень часто возникала необходимость вместо реального объекта подсунуть виртуальный объект.

Например, тестируется код, который работает с базой данных и что-то там меняет. Хорошо чтобы перед каждым тестом состояние этой базы было одним и тем же (иначе тесты будут разные). И базу хотелось бы попроще,  
чтобы быстро эти состояния откатывать.  

Или, например, ты тестируешь код, который рассылает полезные SMS. А для непосредственно рассылок он использует какой-нибудь платный SMS Gateway. Хорошо бы для тестирования кода подсунуть ему некий виртуальный Gateway, чтобы не рассылать сотни SMS непонятно кому.

Или твой код запрашивает данные у других веб-серверов, которые банально недоступны на тестовом сервере. Или ты пишешь код для интернет-платежей, который нужно 50 раз протестировать, и только потом допускать к реальным финансовым каналам.

Думаю, вы поняли… Виртуальные объекты или как их еще называют объекты-заглушки очень полезная штука.

И тут возникает сложность – в Java-то статическая типизация. Значит, чтобы вместо объекта типа `ReadDatabase` присвоить переменной ссылку на объект `VirtualDatabase`, нужно унаследовать класс `VirtualDatabase` от `RealDatabase`.

Затем оказывается, что у класса `RealDatabase` куча приватных методов и переменных, которые хранят ссылки на другие реальные объекты, и нормальную заглушку таким образом не напишешь. В теории хороший, но на практике тупиковый вариант.

И тут нам на помощь приходит `DynamicProxy` (более подробно [можно почитать](https://www.baeldung.com/java-dynamic-proxies)), которые появились еще в Java 5. Она позволяет создавать виртуальные объекты, к которым у компилятора нет претензий.

Такие виртуальные объекты называют **mock’ами** (от слова mock – макет).

```XML
<!-- https://mvnrepository.com/artifact/org.mockito/mockito-core -->
    <dependency>
      <groupId>org.mockito</groupId>
      <artifactId>mockito-core</artifactId>
      <version>5.3.1</version>
      <scope>test</scope>
    </dependency>
```

### @ExtendWith

Библиотека Mockito отлично работает вместе с JUnit, ее можно даже рассматривать как его расширение.

Есть два способа активировать работу библиотеки Mockito в ваших unit-тестах. Первый способ – это добавить специальную аннотацию:

```Java
@ExtendWith(MockitoExtension.class)public class MockitoAnnotationTest {
    ...
}
```

Второй способ – включить ее работу вызвав метод `openMocks()`:

```Java
public class MockitoAnnotationTest {
    @BeforeEachpublic void init() {
        MockitoAnnotations.openMocks(this);}
}
```

### Аннотации Mockito

### @Mock

Есть два способа работы с мок-объектами в Mockito. Первый – это **создать полностью виртуальный объект**, второй – это **обернуть существующий объект** в некую обертку. Начнем с первого.

Чтобы создать полностью виртуальный объект, нужно написать код:

```Java
ИмяКласса имяПеременной = Mockito.mock(ИмяКласса.class);
```

Создание мок класса ArrayList, Методы этого объекта ничего не делают.

```Java
@ExtendWith(MockitoExtension.class)
class MockTest {
    @Test
    public void whenNotUseMockAnnotation_thenCorrect() {
        List mockList = Mockito.mock(ArrayList.class);
        //эти методы не будут ничего делать – это заглушки
        mockList.add("one");
        mockList.add("two");
    }
}
```

этот код можно записать еще короче, так как для этого есть специальная аннотация `@Mock`

```Java
@ExtendWith(MockitoExtension.class)
class MockTest {
    @Mock
    List mockList;

    @Test
    public void whenNotUseMockAnnotation_thenCorrect() {
        //эти методы не будут ничего делать – это заглушки
        mockList.add("one");
        mockList.add("two");
				Class clazz = mockList.getClass();
				System.out.println(clazz); //class org.mockito.codegen.List$MockitoMock$349177944
    }
}
```

### @Spy

Второй важный тип объектов в Mockito – это обертки над существующими объектами. Они позволяют с одной стороны пользоваться уже существующими классами, а с другой – перехватывать обращение ко всем методам и переменным таких объектов: подкорректировать их работу, где это нужно. Используются так же часто, как и Mock-объекты. Чтобы создать обертку над объектом, нужно написать код:

```Java
package com.konovalov.service;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Spy;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.ArrayList;
import java.util.List;

@ExtendWith({MockitoExtension.class})
public class MainTest {
    @Spy
    List<Integer> mockList;

    @BeforeEach
    public void setup(){
        mockList = new ArrayList<>(2);
    }

    @Test
    public void whenMockAnnotation() {
        System.out.println(mockList);
        mockList.add(1);
        mockList.add(2);
        System.out.println(mockList.size());
        System.out.println(mockList.size() + " spy");
    }
}
```

### Методы

### doReturn()

Чтобы при вызове определенного метода, мок-объект вернул определенный результат, то это “правило” можно добавить объекту с помощью кода:

```Java
Mockito.doReturn(результат).when(объект).имяМетода();
```

На самом деле никакого вызова `имяМетода()` тут не происходит. Метод `doReturn()` возвращает специальный proxy-объект с помощью которого следит за вызовами методов объекта и, таким образом, идет запись правила.

Пример:

```Java
package com.konovalov.service;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;

@ExtendWith( MockitoExtension.class)
public class MainTest {
    @Mock
    List mockList;
    @Test
    public void whenMockAnnotation () {
        //создаем правило: вернуть 10 при вызове метода size
        Mockito.doReturn(10).when(mockList).size();
        //тут вызывается метод и вернет 10!!
        assertEquals(10, mockList.size());
    }
}
```

### when()

Есть еще один способ добавить правило поведения к мок-объекту – через вызов метода `Mockito.when()`. Не является предпочтительным, так как может вызвать метод реального объекта.

```Java
Mockito.when(объект.имяМетода()).thenReturn(результат);
```

```Java
@ExtendWith(MockitoExtension.class)
class WhenTest {
    @Mock
    List mockList;

    @Test
    public void whenMockAnnotation() {
        //создаем правило: вернуть 10 при вызове метода size
        Mockito.when(mockList.size() ).thenReturn(10);

        //тут вызывается метод и вернет 10!!
        assertEquals(10, mockList.size());
    }
```

ВАЖНО: используя `when()` можно настроить какой результат будет после повторного обращения к методу, при этом результаты могут быть разные:

```Java
@BeforeEach
this.userDao = Mockito.mock(UserDao.class);
this.userService = new UserService(userDao);

@Test
void shouldDeleteExistedUser() {
Mockito.when(userDao.delete(User1.getId()))
										.thenReturn(true)
										.thenReturn(false);

var deleteResult = userService.delete(2); //true
sout(userService.delete(2)); //false
sout(userService.delete(2)); //false
assertThat(deleteResult).isTrue();
}
```

Mockito выбрасывает org.mockito.exceptions.misusing.UnnecessaryStubbingException:, если stub объекты не используются.  
Тест выбросит исключение, так как stub объект  
`doReturn(true).when(userDao).delete(1);` нигде не используется.

```Java
package com.konovalov.service;

import com.konovalov.UserDao;
import com.konovalov.UserService;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.*;

@ExtendWith( MockitoExtension.class)
public class MainTest {
    @Captor
    private ArgumentCaptor<Integer> captor;

    @Mock()
    private UserDao userDao;

    @InjectMocks
    private UserService userService;


    @Test
    public void whenMockAnnotation() {
        doReturn(true).when(userDao).delete(1);
        assertThat(true).isTrue();
    }
}
```

Можно отключить выбрасывание данного исключения несколькими способами:

- `lenient()`

```Java
@Test
    public void whenMockAnnotation() {
        lenient().doReturn(true).when(userDao).delete(1);
        assertThat(true).isTrue();
    }
}
```

- `@Mock(lenient = true)` deprecated

```Java
@Mock(lenient = true)
    private UserDao userDao;
```

### doReturn(параметры)

Чтобы при определенном параметре метод возвращал что-то определенное, то правило можно записать так:

```Java
Mockito.doReturn(результат).when(объект).имяМетода(параметр);
```

Пример

```Java
@ExtendWith(MockitoExtension.class)
class ParamsTest {
    @Mock
    List mockList;

    @Test
    public void whenMockAnnotation() {
        //добавление первого правила
        Mockito.doReturn("Иван").when(mockList).get(10);
        //добавление второго правила
        Mockito.doReturn("Марья").when(mockList).get(500);

        assertEquals("Иван", mockList.get(10));
        assertEquals("Марья", mockList.get(500));

    }
}
```

Но есть ситуация, когда при разных аргументах должно возвращаться одно значение, реализовать это можно с помощью `any():`

```Java
Mockito.doReturn("Иван").when(mockList).get(any(class));
```

Есть тут пара нюансов. Объект `Mockito.any()` имеет тип `Object`, поэтому для параметров разных типов есть его аналоги:

|   |   |
|---|---|
|Метод|Тип параметра|
|**any()**|Object, включая null|
|**any(ClassName.class)**|ClassName|
|**anyInt()**|int|
|**anyBoolean()**|boolean|
|**anyDouble()**|double|
|**anyList()**|List|

```Java
Mockito.doReturn("Иван").when(mockList).get(1);
Mockito.doReturn("Иван").when(mockList).get(2);
Mockito.doReturn("Иван").when(mockList).get(...);
Mockito.doReturn("Иван").when(mockList).get(n);

//Одной строкой можно записать, все что выше.
Mockito.doReturn("Иван").when(mockList).get(anyInt());
```

### doThrow()

Чтобы метод не вернул, а именно выбросил (throw) исключение, нужно задать правило с помощью метода `doThrow()`.

```Java
Mockito.doThrow(исключение.class).when(объект).имяМетода();
```

Либо через `thenThrow():`

```Java
Mockito.when(объект.имяМетода()).thenThrow(исключение.class);

@ExtendWith(MockitoExtension.class)
class DoThrowTest {
    @Mock    List mockList;    @Testpublic void whenMockAnnotation() {
        Mockito.when(mockList.size() ).thenThrow(IllegalStateException.class);
        mockList.size(); //тут кинется исключение
    }
}
```

Если нужно, чтобы объект-исключение,то необходимо добавить `new`:

```Java
Mockito.doThrow(new Исключение()).when(объект).имяМетода();
```

### Методы с параметрами

### doAnswer()

Рано или поздно наступит ситуация, когда ты захочешь, чтобы этот  
виртуальный метод имел сложное поведение. Например, он должен возвращать  
значения в зависимости от параметров, преобразовывать строку в верхний  
регистр.  

Для этого есть специальный метод – `doAnswer()`, в который передается функция, которая делает то, что тебе нужно:

```Java
Mockito.doAnswer(функция).when(объект).имяМетода(параметр);
```

Пример возведения в квадрат полученного значения из листа.

Метод get() листа, тут не работает как изначально, мы по сути переопределили его работу, теперь при вызове get(параметр), параметр будет возведен в квадрат и возвращен. В общем работа никак не связана с получением элементов по индексу.

```Java
@ExtendWith(MockitoExtension.class)
class DoAnswerTest {
    @Mock
    List mockList;

    @Test
    public void whenMockAnnotation() {
        Mockito.doAnswer(invocation -> {
            int parameter = invocation.getArgument(0);
            return parameter * parameter;
        }).when(mockList).get(anyInt());

        assertEquals(100, mockList.get(10));
        assertEquals(25, mockList.get(5));
    }
}
```

  

  

### verify()

Кроме создания виртуальных объектов, можно убедиться, что тестируемый класс вызвал нужные методы нужных объектов. Более того, вызвал нужное число раз, с правильными параметрами и т.д.

Для этого в Mockito есть `Mockito.verify(…)`. Общее правило, которым задается проверка вызова метода, имеет вид:

```Java
Mockito.verify(объект).имяМетода(параметр);
```

Пример. Во время вызова метода `verify()` мы задали правило, что у объекта `mockitoList` должен вызваться метод `get()` с параметром 10:

```Java
package com.konovalov.service;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.List;

@ExtendWith( MockitoExtension.class)
public class MainTest {
    @Mock
    List mockList;

    @Test
    public void whenMockAnnotation2() {
        Mockito.doReturn("Иван").when(mockList).get(10);
        String name = (String) mockList.get(10);
        Mockito.verify(mockList).get(10);
    }
}
```

Если нужно проверить не просто факт, что метод вызывался, а например, что он вызывался 3 раза. Или он у тебя вызывался в цикле и значит должен был вызваться N раз, можно использовать перегруженный метод `verfiy(объект, количество)`:

```Java
Mockito.verify(объект,количество).имяМетода(параметр);
```

==**Важно!**== Количество – это не тип `int`, а специальный объект, которые может задавать различные шаблоны.

|   |   |
|---|---|
|Метод|Описание|
|never()|Метод никогда не должен вызываться|
|times(n)|n раз|
|atLeast(n)|n или больше раз|
|atLeastOnce()|1 или больше раз|
|atMost(n)|n или меньше раз|
|only()|Должен быть только один вызов и только к этому методу|

```Java
String name1 = mockList.get(1);  //вызов метода
String name2 = mockList.get(2);  //вызов метода
String name3 = mockList.get(3);  //вызов метода

//проверяем, что метод get() вызывался 3 раза
Mockito.verify(mockList, times(3)).get(anyInt());
```

Ты также можешь потребовать, чтобы кроме указанных вызовов метода, **никаких других обращений к объекту не было**. Для этого есть правило:

```Java
Mockito.verifyNoMoreInteractions(объект);
```

### mockStatic()

Проблематика: мок-объекты искусственно создаются через класс `DynamicProxy`.

**А статические методы ни к каким объектам не привязаны и перехватить вызовы к ним через** **`DynamicProxy`** **нельзя.**

Но создатели Mockito написали свой загрузчик классов и с его помощью смогли подменять классы на лету.

Понадобится добавить дополнительную библиотеку в `pom.xml`:

```XML
<!-- https://mvnrepository.com/artifact/org.mockito/mockito-inline -->
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-inline</artifactId>
    <version>5.2.0</version>
    <scope>test</scope>
</dependency>
```

### Чтобы мокировать статический метод нужно:

- Создаем специальный мок-объект класса

```Java
MockedStatic<ИмяКласса>управляющийОбъект =
																 Mockito.mockStatic(ИмяКласса.class);
```

- Добавляем к этому объекту правила работы:

```Java
управляющийОбъект.when(ИмяКласса::имяМетода).thenReturn(результат);
```

- Обязательно **заворачиваем использование этого объекта в** `**try-with-resources**`, чтобы объект сразу удалился и Mockito могло очистить связанные с ним правила.

```Java
@Test
void givenStaticMethodWithNoArgs () {
    try (MockedStatic< StaticUtils> utilities =  Mockito.mockStatic( StaticUtils.class)) {
        //добавляем правило
         utilities.when(StaticUtils::name).thenReturn("Привет");

        //проверяем, что правило работает
        assertEquals("Привет", StaticUtils.name());
    }
}
```

### Порядок вызова методов

Жесткий порядок вызова методов можно задать с помощью специального объекта `InOrder`. Сначала его нужно создать:

`InOrder inOrder = Mockito.inOrder(объект);`

А затем уже ему добавлять правила посредством вызова методов `verify()`.

Пример:

```Java
List<String> mockedList = mock(MyList.class);
mockedList.size();
mockedList.add("a parameter");
mockedList.clear();

InOrder inOrder = Mockito.inOrder(mockedList);
inOrder.verify(mockedList).size();
inOrder.verify(mockedList).add("a parameter");
inOrder.verify(mockedList).clear();
```

### Проверка исключений

Факт того, что исключения возникли, проверяется немного по другому. Для этого нужно использовать метод `assertThrows()`. Общий формат такой проверки имеет вид:

```Java
Assertions.assertThrows(исключение.class, () -> объект.имяМетода());
```

```Java
@ExtendWith(MockitoExtension.class)
class ThenThrowTest {
    @Mock
    List mockList;

    @Test
    public void whenMockAnnotation() {
        //задаем поведение метода (нужно только для демонстрации)
        Mockito.when(mockList.size()).thenThrow(IllegalStateException.class);

        //проверяем бросится ли IllegalStateException при вызове метода size
        assertThrows(IllegalStateException.class, () -> mockList.size());
    }
}
```

### ArgumentCaptor

Позволяет отлавливать аргумент, с которым вызвался мок или спай объект.

Тест нижк будет пройден, так captor.getValue == 1, так как мы вызываем userService.delete(1) с аргументом 1. Эту единицу captor и запоминает.  
  

```Java
@Test
    public void whenMockAnnotation() {
        Mockito.doAnswer(invocation -> {
            int arg = invocation.getArgument(0);
            if (arg == 1 || arg == 2) {
                return true;
            } else {
                return false;
            }
        }).when(userService).delete(Mockito.anyInt());

        ArgumentCaptor<Integer> captor = ArgumentCaptor.forClass(Integer.class);

        boolean result = userService.delete(1);

        Mockito.verify(userService,only()).delete(captor.capture());

        assertThat(captor.getValue()).isEqualTo(1);
    }
```

  

  

### MockitoExtension

```XML
<!-- https://mvnrepository.com/artifact/org.mockito/mockito-junit-jupiter -->
    <dependency>
      <groupId>org.mockito</groupId>
      <artifactId>mockito-junit-jupiter</artifactId>
      <version>5.3.1</version>
      <scope>test</scope>
    </dependency>
```

Подключив данную зависимость можно упростить внедрение зависимостей Mockito объектов. Было так:

```Java
private UserDao userDao;
private UserService userService;

@BeforeEach
void prepareMocks(){
this.userDao = Mockito.spy(new UserDao));
this.userService = new UserService(userDao);
}

    @Test
    public void whenMockAnnotation() {
...
ArgumentCaptor<Integer> captor = ArgumentCaptor.forClass(Integer.class);
...
}
```

Аннотации @Mock и @InjectMocks, а также @Captor позволяют упростить код( в моем случае удалить @BeforeEach полностью и вынести инициализацию captor из тестового метода.  
Необходимо добавить расширение при запуске @ExtendWith( MockitoExtension.class)  

```Java
package com.konovalov.service;

import com.konovalov.UserDao;
import com.konovalov.UserService;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.atLeast;

@ExtendWith( MockitoExtension.class)
public class MainTest {
    @Captor
    private ArgumentCaptor<Integer> captor;

    @Mock
    private UserDao userDao;

    @InjectMocks
    private UserService userService;


    @Test
    public void whenMockAnnotation() {
        Mockito.doAnswer(invocation -> {
            int arg = invocation.getArgument(0);
            if (arg == 1 || arg == 2) {
                return true;
            } else {
                return false;
            }
        }).when(userDao).delete(Mockito.anyInt());

        userService.delete(1);

        Mockito.verify(userDao,atLeast(1)).delete(captor.capture());

        assertThat(captor.getValue()).isEqualTo(1);
    }
}
```

## AssertJ

[https://assertj.github.io/doc/](https://assertj.github.io/doc/)

Подключение:

```XML
<dependency>
  <groupId>org.assertj</groupId>
  <artifactId>assertj-core</artifactId>
  <version>3.24.2</version>
  <scope>test</scope>
</dependency>
```

Импортирование всех assertions:

```Java
import static org.assertj.core.api.Assertions.*;
```

При использовании традиционных ассертов код ваших тестов выглядит искусственным и с трудом читается вслух. Сравните:

```Java
//JUNIT5
final Account a = makeAccount();
assertEquals("RussianAccount{id=1, currency=BaseCurrency(isoCode=RUB), number=30102810100000000001, active=true, balance=0, holder=Party{Revolut LLC, type=LEGAL_PERSON, tax identification number=7703408188, id=1}, chapter=BALANCE}",
    a.toString());
//ASSERTJ plugin
final Account a = makeAccount();
assertThat(a)
    .hasToString("RussianAccount{id=1, currency=BaseCurrency(isoCode=RUB), number=30102810100000000001, active=true, balance=0, holder=Party{Revolut LLC, type=LEGAL_PERSON, tax identification number=7703408188, id=1}, chapter=BALANCE}");

// JUnit
assertEquals(1, cache.size());

// AssertJ
assertThat(cache)
    .hasSize(1);
```

Данная библиотека позволяет использовать цепочку тестов аналогично синтаксису стримов:

```Java
@Test
  void a_few_simple_assertions() {
    assertThat("The Lord of the Rings").isNotNull()   
                                       .startsWith("The") 
                                       .contains("Lord") 
                                       .endsWith("Rings"); 
  }
}
```

Позволяет переопределять сообщения о проваленном тесте. ==**ВАЖНО**== переопределение сообщения об ошибке до терминальной проверки :

```Java
@Test
        public void test(){
            TolkienCharacter frodo = new TolkienCharacter("Frodo", 33, Race.HOBBIT);
            TolkienCharacter sam = new TolkienCharacter("Sam", 38, Race.HOBBIT);
            assertThat(frodo.age()).withFailMessage("Frodo`s age is not same as Sam`s age", frodo)
                    .isEqualTo(sam.age());
 }

java.lang.AssertionError: Frodo`s age is not same as Sam`s age
```

### Частые ошибки

**==Bad==**

```Java
// DON'T DO THIS ! as/describedAs have no effect after the assertion
assertThat(actual).isEqualTo(expected).as("description");
assertThat(actual).isEqualTo(expected).describedAs("description");
```

**==Good==**

```Java
// DO THIS: use as/describedAs before the assertion
assertThat(actual).as("description").isEqualTo(expected);
assertThat(actual).describedAs("description").isEqualTo(expected);
```

### Calling withFailMessage/overridingErrorMessage after the assertion

Setting an error message must be done before calling the assertion  
otherwise it is ignored as a failing assertion breaks will prevent the  
call to  
`withFailMessage()` / `overridingErrorMessage()`.

==**Bad**==

```Java
// DON'T DO THIS ! overridingErrorMessage/withFailMessage have no effect after the assertion
assertThat(actual).isEqualTo(expected).overridingErrorMessage("custom error message");
assertThat(actual).isEqualTo(expected).withFailMessage("custom error message");
```

**==Good==**

```Java
// DO THIS: use overridingErrorMessage/withFailMessage before the assertion
assertThat(actual).overridingErrorMessage("custom error message").isEqualTo(expected);
assertThat(actual).withFailMessage("custom error message").isEqualTo(expected);
```

Установка компаратора должна быть до условия иначе он проигнорируется: `usingComparator()` / `usingElementComparator()`.

**==Bad==**

```Java
// DON'T DO THIS ! Comparator is not used
assertThat(actual).isEqualTo(expected).usingComparator(new CustomComparator());
```

==**Good**==

```Java
// DO THIS:
assertThat(actual).usingComparator(new CustomComparator()).isEqualTo("a");
```

  

  

  

  

  

  

  

  

### Методы [https://assertj.github.io/doc/#assertj-core-common-assertions](https://assertj.github.io/doc/#assertj-core-common-assertions)

## AssertJDB

[https://assertj.github.io/doc/#assertj-db](https://assertj.github.io/doc/#assertj-db)

Позволяет тестировать базы данных.

Добавить зависимость в pom.xml

```Java
<dependency>
  <groupId>org.assertj</groupId>
  <artifactId>assertj-db</artifactId>
  <version>2.0.2</version>
  <scope>test</scope>
</dependency>
```

Пример использования

```Java
import static org.assertj.db.api.Assertions.assertThat;

import org.assertj.db.type.DateValue;
import org.assertj.db.type.Source;
import org.assertj.db.type.Table;

Table table = new Table(dataSource, "members");

// Check column "name" values
assertThat(table).column("name")
        .value().isEqualTo("Hewson")
        .value().isEqualTo("Evans")
        .value().isEqualTo("Clayton")
        .value().isEqualTo("Mullen");

// Check row at index 1 (the second row) values
assertThat(table).row(1)
        .value().isEqualTo(2)
        .value().isEqualTo("Evans")
        .value().isEqualTo("David Howell")
        .value().isEqualTo("The Edge")
        .value().isEqualTo(DateValue.of(1961, 8, 8))
        .value().isEqualTo(1.77);
```

## Rest Assured

[https://github.com/rest-assured/rest-assured/wiki/Usage#static-imports](https://github.com/rest-assured/rest-assured/wiki/Usage#static-imports)

Позволяет тестировать Rest контроллеры

```Java

@RestController
@RequestMapping("/api/v1/choices")
@RequiredArgsConstructor
@CrossOrigin(origins = "http://localhost:3000")
public class ChoiceController {

    private final ChoiceService choiceService;
@PostMapping("")
    public ResponseEntity<Choice> saveChoice(@RequestBody Choice choice){
        return ResponseEntity.ok(choiceService.saveChoice(choice));
    }
```

```Java

@RequiredArgsConstructor
@IT
class ChoiceControllerIT {
  

    @BeforeEach
    public void setUp() {
        RestAssured.baseURI = "http://localhost:8080"; // Укажите базовый URL вашего приложения
    }
@Test
    void saveChoice(){
        Choice choice = new Choice();
        choice.setSymptom("Новый симптом");
        choice.setOrderValue(1);

        RestAssured.given()
                .contentType("application/json")
                .body(choice)
                .when()
                .post("/api/v1/choices")
                .then()
                .statusCode(200)
                .contentType("application/json")
                .body("symptom", Matchers.notNullValue());

    }
}
```

1. `RestAssured.given()...`: Этот блок использует библиотеку RestAssured для отправки HTTP-запроса к API. Он настраивает запрос, устанавливая заголовок "Content-Type" как "application/json" и отправляет объект `choice` в виде JSON-тела запроса.
2. `.when()...`: Этот блок указывает, что делать после настройки запроса. В данном случае, выполняется HTTP POST-запрос на путь "/api/v1/choices".
3. `.then()...`: Здесь определяются ожидания после выполнения запроса. В данном случае, ожидается, что:
    - `.statusCode(200)`: HTTP-статус ответа должен быть равен 200 (Успешный запрос).
    - `.contentType("application/json")`: Заголовок "Content-Type" ответа должен быть "application/json".
    - `.body("symptom", Matchers.notNullValue())`: В теле ответа должно присутствовать поле "symptom", которое не должно быть пустым (notNullValue()).