---
title: Дедуплекация Собственный пул строк
tags:
  - JavaSE
  - String
related_topics: 
created: 2024-09-02 18:30
modified: 2024-09-04T13:11:35+03:00
difficulty: 
questions: 
notes: 
links:
  - https://topjava.ru/blog/compact-strings-java-9
---
# Собственный пул строк  

Что же тогда делать, если мы создаем много объектов класса _String_? Нам ничего не мешает написать свой собственный пул строк, доступ к которому может быть быстрее, чем к пулу виртуальной машины. После того, как он справится со своей работой, его можно легко уничтожить.  

Рассмотрим пример (источник: доклад [Алексея Шипилёва — «Катехизис java.lang.String»](https://www.youtube.com/watch?v=SZFe3m1DV1A), код доработан):  

```java
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class CHMInterner <T> {
    private final Map<T, T> map;

    public CHMInterner() {
        map = new ConcurrentHashMap<>();
    }

    public T intern(T t) {
        T exist = map.putIfAbsent(t, t);
        return (exist == null) ? t : exist;
    }

    public int internSize() {
        return map.size();
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        CHMInterner chmInterner = new CHMInterner();

        chmInterner.intern("TopJava_1");
        chmInterner.intern("TopJava_2");
        chmInterner.intern("TopJava_2");
        chmInterner.intern("TopJava_3");
        chmInterner.intern("TopJava_3");
        chmInterner.intern("TopJava_3");
        chmInterner.intern("TopJava_4");
        chmInterner.intern("TopJava_4");
        chmInterner.intern("TopJava_4");
        chmInterner.intern("TopJava_4");

        System.out.println("Размер пула строк равен: " + chmInterner.internSize());
    }
}
```

Результат выполнения программы:  

![](https://optim.tildacdn.com/tild3636-3566-4337-a538-666235643334/-/resize/760x/-/format/webp/carbon_34.png)

Таким образом, на основе _ConcurrentHashMap_ был создан пул строк, в который мы пытались добавить 10 повторяющихся строк. В итоге были добавлены только 4 уникальных строки.

## <mark class="hltr-orange">Сборщик мусора для String</mark>
До Java версии 7 виртуальная машина размещала пул строк в области памяти под названием [PermGen](https://topjava.ru/blog/permgen-and-metaspace), которая имеет фиксированный размер и не может быть расширена во время выполнения приложения. Также следует отметить, что на эту область памяти не распространяется действие сборщика мусора.  

Риск интернирования строк в область PermGen (вместо кучи) заключается в том, что мы можем получить от JVM ошибку OutOfMemoryError, если будем интернировать слишком много строк (PermGen имеет фиксированный размер).  

Учтите, что однажды интернированную строку в версии Java ниже 7й нельзя деинтернировать: она будет занимать память программы даже тогда, когда перестанет быть нужна. Из этого следует, что чрезмерное интернирование строк может оказать негативный эффект, связанный с утечками памяти!  

Начиная с Java 7, пул строк размещается в куче, на которую распространяется процесс сборки мусора. Преимуществом данного подхода является снижение вероятности появления ошибки OutOfMemoryError, так как строки, на которые не будет ссылаться ни одна переменная в выполняемой программе, будут удалены сборщиком мусора из пула, что приведет к освобождению памяти.


## <mark class="hltr-orange">Дедупликация</mark>  

Как мы написали в самом начале, класс _String_ представляет собой массив байт:  

```java
private final byte[] value;
```

А т.к. созданный экземпляр класса String нельзя модифицировать, т. е. содержимое массива _value[]_ нельзя изменить_,_ то его значение может быть безопасно использовано одновременно несколькими объектами _String._  

[Дедупликация](https://openjdk.java.net/jeps/192) представляет собой не что иное, как переприсваивание виртуальной машиной адресов поля _value_. Т. е. мы выполняем дедупликацию не объектов _String,_ а массивов их байт. Поля _value_ нескольких объектов типа String с одинаковым значением текста изначально ссылаются на разные участки памяти (разные массивы байт), а после дедупликации будут ссылаться на один и тот же участок памяти, содержащий массив байт.  

Кроме того, у нас все еще остаются накладные расходы в виде заголовка объекта, полей и др. Такие накладные расходы зависят от платформы/конфигурации и варьируются в пределах от 24 до 32 байт. Однако, для средней длины объекта _String_ в 45 символов (90 байт + заголовок массива), это все еще значительные цифры. Принимая во внимание вышеперечисленное, актуальный выигрыш в экономии памяти может быть около 10%.  

###  <mark class="hltr-orange">Как работает дедупликация  </mark>

Во время сборки мусора GC проверяет живые (имеющие рабочие ссылки) объекты в куче на возможность провести их дедупликацию. Ссылки на подходящие объекты вставляются в очередь для последующей обработки. Далее происходит попытка дедупликации каждого объекта _String_ из очереди, а затем удаление из нее ссылок на объекты, на которые они ссылаются. Также для отслеживания всех уникальных массивов байт, используемых объектами _String,_ используется хеш-таблица. При дедупликации в этой хеш-таблице выполняется поиск идентичных массивов байт (символов).  

При положительном результате значение поля _value_ объекта _String_ переприсваивается так, чтобы указывать на этот существующий массив байт. Соответственно, предыдущий массив байт _value_ становится ненужным — на него ничего не ссылается и впоследствии он попадает под сборку мусора.  

При отрицательном результате, массив байт, соответствующий _value,_ вставляется в хеш-таблицу, чтобы впоследствии быть использованным совместно с новым объектом _String_ в какой-то другой момент в будущем.  

Давайте поэкспериментируем, запустив следующую программу:  

```java
import java.lang.reflect.Field;

public class DeduplicationDemo {

    public static void main(String[] args) throws InterruptedException, NoSuchFieldException, IllegalAccessException {
        char[] chars = {'T', 'o', 'p', 'J', 'a', 'v', 'a'};
        String[] strings = {new String(chars), new String(chars)};
        Field value = String.class.getDeclaredField("value");
        value.setAccessible(true);

        System.out.println("Хеш первого объекта: " + value.get(strings[0]));
        System.out.println("Хеш второго объекта: " + value.get(strings[1]));

        System.gc();
        System.out.println("Запустили сборщик мусора");
        Thread.sleep(100);

        System.out.println("Хеш первого объекта: " + value.get(strings[0]));
        System.out.println("Хеш второго объекта: " + value.get(strings[1]));
    }
}
```

Результат выполнения программы:  

![](https://optim.tildacdn.com/tild3934-3338-4931-a536-393536633765/-/resize/760x/-/format/webp/carbon_37.png)

Как видим, дедупликация не сработала.<mark class="hltr-yellow"> Для ее активации необходимо в параметрах виртуальной машины указать</mark> <mark class="hltr-red">-_XX:+UseStringDeduplication_</mark>, а<mark class="hltr-yellow"> также активировать сборщик мусора G1</mark> (если он не используется по умолчанию), указав также <mark class="hltr-red">-_XX:+UseG1GC_.  </mark>

В этом случае имеем правильный результат выполнения программы:  

![](https://optim.tildacdn.com/tild6465-6536-4336-b434-383836346334/-/resize/760x/-/format/webp/carbon_38.png)

Результат говорит о следующем: создав два объекта с помощью _new,_ мы получили два разных объекта с разными идентификационными хешами для массивов байт. Запустив сборщик мусора и подождав некоторое время (дедупликация не происходит мгновенно), мы видим, что хеши для двух объектов стали одинаковы (ссылаются на один и тот же массив).  

Иллюстративно это выглядит так:  

![](https://optim.tildacdn.com/tild6439-3131-4434-b163-346638633238/-/resize/760x/-/format/webp/pasted_image_0_3.png)

Видоизменим немного код, добавив в массив строковый литерал:  

```java
import java.lang.reflect.Field;

public class DeduplicationDemo {

    public static void main(String[] args) throws InterruptedException, NoSuchFieldException, IllegalAccessException {
        char[] chars = {'T', 'o', 'p', 'J', 'a', 'v', 'a'};
        String[] strings = {new String(chars), new String(chars), "TopJava"};
        Field value = String.class.getDeclaredField("value");
        value.setAccessible(true);

        System.out.println("Хеш первого объекта: " + value.get(strings[0]));
        System.out.println("Хеш второго объекта: " + value.get(strings[1]));
        System.out.println("Хеш третьего объекта: " + value.get(strings[2]));

        System.gc();
        System.out.println("Запустили сборщик мусора");
        Thread.sleep(100);

        System.out.println("Хеш первого объекта: " + value.get(strings[0]));
        System.out.println("Хеш второго объекта: " + value.get(strings[1]));
        System.out.println("Хеш третьего объекта: " + value.get(strings[2]));
    }
}
```

Результат выполнения программы:  

![](https://optim.tildacdn.com/tild6231-3864-4038-b632-366166356335/-/resize/760x/-/format/webp/carbon_42.png)

Иллюстративно это выглядит так:  

![](https://optim.tildacdn.com/tild3262-3430-4637-b164-356134313062/-/resize/760x/-/format/webp/pasted_image_0_4.png)

Создав строковый литерал _str3_, мы, тем самым, строку «_TopJava_» добавили в пул строк. <mark class="hltr-yellow">Во время дедупликации виртуальная машина увидев, что в пуле строк уже содержится такой массив байт, изменила адрес массива</mark> _byte[]_ <mark class="hltr-yellow">для созданных через конструктор строковых объектов на адрес массива</mark> _byte[]_ с<mark class="hltr-yellow">трокового литерала, находящегося в пуле строк.  </mark>

Чтобы убедиться, что этот результат был получен благодаря дедупликации, попробуйте отключить функционал дедупликации строк в виртуальной машине.  

<mark class="hltr-orange">Ключевые моменты:  </mark>

- Дедупликация строк доступна с _Java 8 Update 20_
- Она активируется параметром для виртуальной машины: _-XX:+UseStringDeduplication_
- Дедупликация строк работает только со сборщиком мусора _G1_. Для его активации в _Java 8_ необходимо указать параметр для виртуальной машины _-XX:+UseG1GC_. Начиная с _Java 9_, G1 является сборщиком мусора по умолчанию
- Опыты показывают, что применение дедупликации строк сокращает расходы кучи на примерно 10%, что, в принципе, неплохо, учитывая, что нам не нужно вносить изменение в код
- Дедупликация строк работает в фоновом режиме без приостановления работы приложения
- В отличие от пула строк, который применим только для строк, интернированных командой _intern()_, или строковых литералов, но не применим для строк, созданных динамически во время жизни приложения, дедупликация строк применима для строк, созданных всеми этими способами
#### <mark class="hltr-orange">**Алгоритм дедупликации строк**</mark>

Механизм дедупликации строк выполняется следующим образом:

1. **Анализ строки:**
    
    - Во время сборки мусора <mark class="hltr-yellow">G1 GC анализирует кучу и находит строки, которые потенциально могут быть дедуплицированы</mark>. Этот процесс осуществляется, когда строки перемещаются между различными регионами памяти (например, из молодого поколения в старое).
2. **Создание хэша:**
    
    - <mark class="hltr-red">Для каждой строки создается хэш-значение на основе содержимого строки</mark>. Это значение используется для идентификации строк с одинаковым содержимым.
3. **Поиск дубликатов:**
    
    - <mark class="hltr-red">JVM</mark><mark class="hltr-green2"> сравнивает хэш-значения строк и проверяет, существуют ли в памяти другие строки с таким же хэш-значением и содержимым.</mark>
4. **Замена строк:**
    
    - Если дубликат найден, JVM сохраняет только одну копию строки в памяти, а остальные экземпляры заменяются ссылками на оригинальную строку.
5. **Удаление избыточных строк:**
    
    - Избыточные строки (те, которые были заменены ссылками) удаляются, освобождая память.

#### 4. **Активация дедупликации строк**

Для активации дедупликации строк в JVM нужно использовать следующие параметры JVM:

- `-XX:+UseG1GC`: Включает использование сборщика мусора G1.
- `-XX:+UseStringDeduplication`: Включает механизм дедупликации строк.

Дополнительные параметры для настройки:

- `-XX:StringDeduplicationAgeThreshold=<N>`: Указывает минимальный возраст объекта строки (в числе циклов сборки мусора), начиная с которого будет производиться дедупликация. По умолчанию это значение равно 3.
    
- `-XX:+PrintStringDeduplicationStatistics`: Включает вывод статистики о процессе дедупликации строк в лог, что полезно для мониторинга эффективности этого механизма.
    

#### 5. **Преимущества дедупликации строк**

- **Экономия памяти:** Дедупликация строк позволяет значительно уменьшить объем используемой памяти за счет устранения дублирующих строк.
- **Снижение нагрузки на GC:** Уменьшение числа строковых объектов в памяти может снизить нагрузку на сборщик мусора, так как ему приходится управлять меньшим количеством объектов.
- **Повышение производительности:** В некоторых случаях, за счет снижения использования памяти и уменьшения фрагментации, дедупликация строк может привести к улучшению общей производительности приложения.

#### 6. **Ограничения и соображения**

- **Нагрузки:** Хотя дедупликация строк может значительно снизить объем используемой памяти, она также требует дополнительных вычислительных ресурсов для анализа строк и поиска дубликатов. Это может несколько увеличить нагрузку на процессор.
- **Применимость:** Эффективность дедупликации строк зависит от характера приложения. В приложениях, где мало дублирующихся строк или большинство строк и так находятся в пуле строк, выгоды могут быть минимальными.
- **Задержка:** Включение дедупликации может вызвать небольшие задержки в работе сборщика мусора, особенно если в приложении много короткоживущих строк.