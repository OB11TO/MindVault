---
title: Блокировки и  MVCC (Multiversion Concurrency Control)
tags: 
related_topics: 
created: 2024-09-26 18:26
modified: 2024-09-27T13:10:51+03:00
questions: 
notes: 
links: 
---

Блокировки и **MVCC** (Multiversion Concurrency Control) — это два разных механизма, которые в PostgreSQL и других СУБД используются для решения разных задач, связанных с параллельной обработкой транзакций.

### Основная разница:

- **MVCC** — <mark class="hltr-yellow">это способ управления параллельным доступом к данным, при котором одновременно могут существовать несколько версий одной и той же строки (tuple)</mark>. Он предотвращает проблемы, связанные с чтением непоследовательных данных (например, грязные чтения) и управляет видимостью данных для транзакций.
- **Блокировки** (locks) — <mark class="hltr-green2">это механизм защиты от конфликтов при одновременном изменении данных</mark>. Они <mark class="hltr-red">предотвращают проблемы, которые возникают, когда несколько транзакций пытаются одновременно изменить одни и те же строки.</mark>

### Зачем нужны блокировки, если у нас есть MVCC?

**MVCC** решает проблему конкуренции при чтении данных, но не решает проблемы, связанные с конкуренцией при записи данных. Вот несколько ситуаций, где **MVCC** не может полностью заменить блокировки, и блокировки становятся необходимы:

#### 1. **Конфликт при изменении данных (write-write conflict)**

- **MVCC** позволяет нескольким транзакциям одновременно читать одну и ту же строку, создавая для каждой свою "версию" данных. Однако, если несколько транзакций пытаются **одновременно изменить одни и те же строки**, возникает конфликт. Здесь нужно гарантировать, что данные будут корректно изменены.
- Например, если две транзакции одновременно пытаются изменить одну строку, одна из них должна "заблокировать" эту строку, чтобы другая не смогла сделать изменения до тех пор, пока первая транзакция не завершится (COMMIT или ROLLBACK).
- **Блокировка** защищает данные от некорректных изменений и потерь обновлений, когда изменения одной транзакции могут быть перезаписаны другой.

**Пример:**

- Транзакция T1 обновляет строку `{id=1, salary=5000}`.
- Транзакция T2 в то же время пытается обновить ту же строку.
- Одна из транзакций должна ждать завершения другой, иначе результат обновлений будет непредсказуем.

#### 2. **Избежание потерь данных (lost updates)**

- Без блокировок при параллельном изменении строк данные могут потеряться. Например, транзакция T1 читает данные и изменяет их, а T2 в это время читает те же данные. Если обе транзакции изменят строку и запишут результат, одно из изменений будет потеряно.
- **Блокировки** помогают предотвратить потерю обновлений, гарантируя, что одна транзакция завершит свои изменения, прежде чем другая начнет свои.

#### 3. **Поддержание целостности данных**

- В некоторых случаях блокировки необходимы для того, чтобы поддерживать логическую целостность данных, особенно когда несколько транзакций одновременно работают с взаимосвязанными данными.
- Например, при работе с внешними ключами, если одна транзакция удаляет строку, которая ссылается на другую таблицу, другая транзакция не должна иметь возможность вставлять или изменять связанные данные до завершения первой транзакции.

#### 4. **Индексные блокировки**

- Блокировки применяются не только к данным, но и к структурам данных, таким как индексы. Если транзакция изменяет индекс, другая транзакция не должна иметь возможность работать с этим индексом, пока не завершатся изменения.

#### 5. **Блокировки на уровне таблиц и схем**

- Блокировки применяются также для предотвращения конфликтов на уровне всей таблицы или схемы данных. Например, если идет изменение структуры таблицы (например, добавление столбцов), другие транзакции должны быть заблокированы, чтобы избежать неконсистентных состояний схемы.

### Типы блокировок в PostgreSQL:

1. **Блокировки на уровне строк**:
    
    - **Row-level locks (строчные блокировки)** — это наиболее используемый тип блокировок, который предотвращает одновременные изменения одной и той же строки в разных транзакциях. Блокировки строк нужны, чтобы предотвратить **потерю обновлений** и **конфликты при записи**.
2. **Блокировки на уровне таблиц**:
    
    - Например, для операций изменения схемы, когда транзакция добавляет столбцы или удаляет таблицу, применяется **блокировка на уровне таблицы**.
3. **Блокировки для индексов**:
    
    - Когда идет работа с индексами (например, пересоздание индексов), необходимо предотвратить доступ к индексам другим транзакциям, чтобы избежать нарушения их целостности.
4. **Шеринговые и эксклюзивные блокировки**:
    
    - **Шеринговая блокировка (Shared Lock)** позволяет нескольким транзакциям читать данные, но блокирует изменения.
    - **Эксклюзивная блокировка (Exclusive Lock)** — блокирует и чтение, и запись, пока транзакция не завершит свои изменения.

### Пример работы блокировок:

Предположим, у нас есть две транзакции, которые пытаются одновременно изменить одну и ту же строку:

1. Транзакция T1:

```sql
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;

```

Транзакция T2:
```sql
BEGIN;
UPDATE accounts SET balance = balance + 200 WHERE id = 1;

```

Если бы не было блокировок, обе транзакции могли бы завершиться, перезаписывая изменения друг друга, что приведет к потере данных. Но благодаря блокировкам:

- Когда T1 начинает изменять строку с `id = 1`, PostgreSQL ставит **эксклюзивную блокировку** на эту строку.
- T2 должна будет ждать завершения T1, прежде чем она сможет изменить те же данные.
- Когда T1 завершится (выполнит COMMIT или ROLLBACK), блокировка будет снята, и T2 сможет продолжить свои изменения.

### Почему блокировки и MVCC дополняют друг друга?

**MVCC** позволяет транзакциям читать старые версии данных, избегая блокировок на чтение и повышая конкурентность чтений. Однако, для записей и одновременных изменений данных блокировки необходимы, чтобы защитить данные от некорректного изменения.

- **MVCC** управляет параллельными **чтениями**, обеспечивая согласованность версий данных без необходимости блокировок для чтения. Это позволяет одновременно читать данные, не блокируя доступ для других транзакций.
- **Блокировки** нужны для управления параллельными **записями**. Без блокировок транзакции могли бы перезаписывать изменения друг друга, что привело бы к потере данных или несогласованности.

### Проблемы, которые решают блокировки:

- **Потеря обновлений**: если транзакции одновременно пытаются изменить одну и ту же строку.
- **Конфликт записей**: предотвращение одновременных изменений тех же данных.
- **Согласованность индексов и таблиц**: предотвращение некорректных изменений в индексах или структуре таблиц.

### Заключение:

- **MVCC** решает проблему конкурентного **чтения** данных, позволяя транзакциям видеть разные версии строк без блокировок.
- **Блокировки** необходимы для управления конкурентными **записями** данных, чтобы защитить данные от конфликтов и потерь.

Таким образом, **MVCC** и блокировки вместе помогают обеспечить высокую конкурентность доступа и целостность данных в PostgreSQL. **MVCC** снимает нагрузку с блокировок для чтения, улучшая производительность и снижая задержки, тогда как блокировки предотвращают конфликты при параллельных изменениях данных